(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{346:function(o,t,e){"use strict";e.r(t);var r=e(7),a=Object(r.a)({},(function(){var o=this,t=o._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("h1",{attrs:{id:"使用热更新monobehaviour和scriptableobject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用热更新monobehaviour和scriptableobject"}},[o._v("#")]),o._v(" 使用热更新MonoBehaviour和ScriptableObject")]),o._v(" "),t("p",[o._v("HybridCLR完全支持热更新MonoBehaviour和ScriptableObject工作流。你可以无任何限制地通过代码 "),t("code",[o._v("go.AddComponent<T>()或go.AddComponent(typeof(T))")]),o._v("来添加运行时热更新脚本。")]),o._v(" "),t("p",[o._v("你也可以在资源上直接挂载热更新MonoBehaviour或者使用 ScriptableObject类对应的资源，但有一些限制，这些限制是Unity的资源管理系统造成的。")]),o._v(" "),t("p",[o._v("Unity资源管理系统在反序列化资源中的热更新脚本时，需要满足以下条件：")]),o._v(" "),t("ol",[t("li",[o._v("脚本所在的dll已经加载到运行时中")]),o._v(" "),t("li",[o._v("必须是使用AssetBundle打包的资源（"),t("strong",[o._v("addressable之类间接使用了ab的框架也可以")]),o._v("）")]),o._v(" "),t("li",[o._v("脚本所在的dll必须添加到打包时生成的assembly列表文件。这个列表文件是unity启动时即加载的，不可变数据。不同版本的Unity的列表文件名和格式不相同。")])]),o._v(" "),t("p",[o._v("详细原理请看"),t("RouterLink",{attrs:{to:"/hybridclr/monobehaviour/"}},[o._v("热更新MonoBehaviour")]),o._v("。")],1),o._v(" "),t("p",[o._v("对于新手来说，你只需要记住：挂载热更新脚本的资源（场景或prefab）必须打包成ab，在实例化资源前先加载热更新dll即可（这个要求是显然的！）。")])])}),[],!1,null,null,null);t.default=a.exports}}]);