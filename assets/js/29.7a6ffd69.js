(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{349:function(r,a,t){"use strict";t.r(a);var e=t(7),l=Object(e.a)({},(function(){var r=this,a=r._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"hybridclr-lua-js-python"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hybridclr-lua-js-python"}},[r._v("#")]),r._v(" HybridCLR+lua/js/python")]),r._v(" "),a("p",[r._v("有一些项目已经上线，它们的大多数代码已经用lua实现了；或者一些新项目已经用lua开发到一半，他们无法完全切换为全C#开发，但希望\n可以同时接入HybridCLR，帮助慢慢过渡到全部原生C#热更新。")]),r._v(" "),a("p",[r._v("由于HybridCLR是原生C#热更新技术，原生支持与这些脚本语言配合工作。你要做的，仅仅是将那些要热更新wrapper文件生成到热更新模块，\n同时提前预留足够多的ReversePInvoke函数，详细文档见"),a("RouterLink",{attrs:{to:"/hybridclr/monopinvokecallback/"}},[r._v("MonoPInvokeCallback支持")]),r._v("。")],1),r._v(" "),a("p",[r._v("由于很多热更新方案如xlua并未考虑过模块化，生成的代码全在全局Assembly-CSharp里，甚至做成partial类与Runtime代码关联，因此你可能需要对这些热更新方案的生成代码做少量调整，才能与热更新配合工作。")]),r._v(" "),a("h2",{attrs:{id:"xlua"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xlua"}},[r._v("#")]),r._v(" xlua")]),r._v(" "),a("p",[r._v("已经有群友制作了 "),a("code",[r._v("HybridCLR + xlua")]),r._v(" 的项目 "),a("a",{attrs:{href:"https://gitee.com/ldr123/HybridCLRXlua",target:"_blank",rel:"noopener noreferrer"}},[r._v("HybridCLRXlua"),a("OutboundLink")],1),r._v("。已经跑通并且完善了工作流。\n强烈推荐参考。")]),r._v(" "),a("h2",{attrs:{id:"tolua、slua、puerts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tolua、slua、puerts"}},[r._v("#")]),r._v(" tolua、slua、puerts")]),r._v(" "),a("p",[r._v("确保预留了足够多的ReversePInvokeWrapper函数并且生成的wrapper代码能放到热更新模块，并且正确注册即可。")])])}),[],!1,null,null,null);a.default=l.exports}}]);