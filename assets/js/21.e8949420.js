(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{341:function(t,e,s){"use strict";s.r(e);var r=s(7),a=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"项目设置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#项目设置"}},[t._v("#")]),t._v(" 项目设置")]),t._v(" "),e("p",[t._v("安装完hybridclr_unity包后，需要对项目进行AOT/热更新 assembly拆分，并且正确设置相关配置参数。")]),t._v(" "),e("h2",{attrs:{id:"配置playersettings"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置playersettings"}},[t._v("#")]),t._v(" 配置PlayerSettings")]),t._v(" "),e("ul",[e("li",[t._v("关闭增量式GC(Use Incremental GC) 选项。因为目前不支持增量式GC。WebGL平台忽略此选项。")]),t._v(" "),e("li",[e("code",[t._v("Scripting Backend")]),t._v(" 切换为 "),e("code",[t._v("il2cpp")]),t._v(", WebGL平台不用设置此选项。")]),t._v(" "),e("li",[e("code",[t._v("Api Compatability Level")]),t._v(" 切换为 "),e("code",[t._v(".Net 4 or .Net Framework")]),t._v(" (打主包时可以使用.net standard，但使用脚本Compile热更新dll时必须切换到"),e("code",[t._v(".Net 4.x or .Net Framework")]),t._v(")。如果你要一定要热更新部分也使用.net standard，请找我们"),e("RouterLink",{attrs:{to:"/hybridclr/price/"}},[t._v("商业化服务")]),t._v("。")],1)]),t._v(" "),e("h2",{attrs:{id:"热更新模块拆分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#热更新模块拆分"}},[t._v("#")]),t._v(" 热更新模块拆分")]),t._v(" "),e("p",[t._v("很显然，项目必须拆分为AOT（即编译到游戏主包内）和热更新 assembly，才能进行热更新。HybridCLR对于\n怎么拆分程序集并无任何限制，甚至你将AOT或者热更新程序集放到第三方工程中也是可以的。")]),t._v(" "),e("p",[t._v("常见的拆分方式有几种：")]),t._v(" "),e("ul",[e("li",[t._v("Assembly-CSharp作为AOT程序集。剩余代码自己拆分为0-N个程序集。")]),t._v(" "),e("li",[t._v("Assembly-CSharp作为热更新程序集。剩余代码自己拆分为1-N个程序集（实践中至少得有一个负责热更新的AOT启动程序集）。")])]),t._v(" "),e("p",[t._v("第一种需要自己设置好热更新对AOT程序集的引用，并且由于Unity自身的原因，Assembly-CSharp是最顶层assembly，它会自动引用剩余所有assembly，\n实践中很容易出现热更新assembly的代码被Assembly-CSharp意外引用，导致打包出错的情况。因此推荐新手将Assembly-CSharp作为热更新程序集。")]),t._v(" "),e("p",[t._v("无论哪种拆分方式，正确设置好程序集之间的引用关系即可")]),t._v(" "),e("h2",{attrs:{id:"配置-hybridclr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置-hybridclr"}},[t._v("#")]),t._v(" 配置 HybridCLR")]),t._v(" "),e("p",[t._v("配置相关详细文档可见 "),e("RouterLink",{attrs:{to:"/hybridclr/hybridclr_unity/"}},[t._v("hybridclr_unity包介绍")]),t._v("。")],1),t._v(" "),e("p",[t._v("点击菜单 "),e("code",[t._v("HybridCLR/Settings")]),t._v(" 打开配置界面，新手关心 "),e("code",[t._v("hotUpdate Assembly Definitions")]),t._v(" 和 "),e("code",[t._v("hotUpdate dlls")]),t._v(" 字段即可。")]),t._v(" "),e("p",[t._v("对于项目中的热更新程序集，如果是assembly definition(asmdef)定义的程序集，加入\n"),e("code",[t._v("hotUpdateAssemblyDefinitions")]),t._v("列表，如果是普通dll，则将程序集名字（不包含'.dll'后缀，如Main、Assembly-CSharp）加入"),e("code",[t._v("hotUpdateAssemblies")]),t._v("即可。这两个列表是等价的，不要重复添加，否则会报错。")]),t._v(" "),e("p",[t._v("如果你的热更新代码在外部项目中，例如使用ET之类的框架，它的热更新代码并不放到Unity项目中，则可以在"),e("code",[t._v("externalHotUpdateAssemblyDirs")]),t._v("\n配置项中指定外部热更新dll的搜索路径。注意，这个路径是相对路径，相对于Unity项目根目录。")]),t._v(" "),e("p",[e("strong",[t._v("至此完成热更新相关的所有设置")]),t._v("。")])])}),[],!1,null,null,null);e.default=a.exports}}]);