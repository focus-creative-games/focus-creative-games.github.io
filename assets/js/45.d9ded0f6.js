(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{365:function(t,v,_){"use strict";_.r(v);var r=_(7),a=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"aot-interpreter-桥接函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#aot-interpreter-桥接函数"}},[t._v("#")]),t._v(" AOT-interpreter 桥接函数")]),t._v(" "),v("p",[t._v("桥接函数HybridCLR的interpreter与AOT之间需要双向函数调用。比如，interpreter调用AOT函数，或者AOT部分有回调函数会调用解释器部分。")]),t._v(" "),v("p",[t._v("AOT部分与解释器部分的参数传递和存储方式是不一样的。比如解释器部分调用AOT函数，解释器的参数全在解释器栈上，必须借助合适的办法才能将解释器的函数参数传递给AOT函数。同样的，解释器无法直接获得AOT回调函数的参数。必须为每一种签名的函数生成对应的桥接函数，来实现解释器与aot部分的双向函数参数传递。")]),t._v(" "),v("p",[v("code",[t._v("interpreter -> AOT")]),t._v(" 方向的调用，虽然可以通过ffi之类的库来完成，但函数调用的成本过高，最合理的方式仍然是提前生成好这种双向桥接函数。")]),t._v(" "),v("p",[t._v("解释器内部调用直接走解释器栈，不需要桥接函数。")]),t._v(" "),v("p",[t._v("根据桥接函数的原理，对于固定的AOT部分，桥接函数集是确定的，后续无论进行任何热更新，都不会需要新的额外桥接函数。"),v("strong",[t._v("因此不用担心热更上线后突然出现桥接函数缺失的问题。")])]),t._v(" "),v("h2",{attrs:{id:"桥接函数签名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#桥接函数签名"}},[t._v("#")]),t._v(" 桥接函数签名")]),t._v(" "),v("p",[t._v("桥接函数必须提前在AOT部分生成，这点跟lua的wrapper函数原理相似。")]),t._v(" "),v("p",[t._v("为了给每个"),v("code",[t._v("AOT <-> interpreter")]),t._v("之间调用的函数找到对应的桥接函数，必须有一种计算函数签名的方式。另外，参数类型和返回值类型完全等效的函数可以共享同一个桥接函数，这极大减少了桥接函数的个数。如下示例，对于x64和arm64平台, long、class类型共享相同的签名。因此它们都可以共享一个 "),v("code",[t._v("long (long, long)")]),t._v(" 签名的桥接函数。")]),t._v(" "),v("div",{staticClass:"language-csharp line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-csharp"}},[v("code",[v("span",{pre:!0,attrs:{class:"token return-type class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("Fun1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")])]),t._v(" a"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")])]),t._v(" b"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token return-type class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("Fun2")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")])]),t._v(" a"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")])]),t._v(" b"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token return-type class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")])]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("Fun3")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")])]),t._v(" a"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("object")])]),t._v(" b"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("p",[t._v("不同操作系统及architecture的ABI的处理函数参数传递和返回值的方式有一些区别。考虑到Android v8和iOS都是arm64，为了最大化优化这两个常见平台的性能，同时平衡维护过多平台的成本，我们索性针对32和64位各设计了一个最严格签名计算规则，分别叫Universal32和Universal64，以及专门对手游arm 64位平台设计了Arm64族桥接签名计算规则。")]),t._v(" "),v("ul",[v("li",[t._v("Arm64")]),t._v(" "),v("li",[t._v("Universal32 使用所有32位平台的abi交集的方式计算签名")]),t._v(" "),v("li",[t._v("Universal64 使用除arm64平台以外的abi交集的方式计算签名")])]),t._v(" "),v("h3",{attrs:{id:"universal32-的签名规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#universal32-的签名规则"}},[t._v("#")]),t._v(" Universal32 的签名规则")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("类型")]),t._v(" "),v("th",[t._v("签名")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("bool、byte")]),t._v(" "),v("td",[t._v("u1")])]),t._v(" "),v("tr",[v("td",[t._v("sbyte")]),t._v(" "),v("td",[t._v("i1")])]),t._v(" "),v("tr",[v("td",[t._v("short")]),t._v(" "),v("td",[t._v("i2")])]),t._v(" "),v("tr",[v("td",[t._v("ushort、char")]),t._v(" "),v("td",[t._v("u2")])]),t._v(" "),v("tr",[v("td",[t._v("int")]),t._v(" "),v("td",[t._v("i4")])]),t._v(" "),v("tr",[v("td",[t._v("uint")]),t._v(" "),v("td",[t._v("u4")])]),t._v(" "),v("tr",[v("td",[t._v("long")]),t._v(" "),v("td",[t._v("i8")])]),t._v(" "),v("tr",[v("td",[t._v("ulong")]),t._v(" "),v("td",[t._v("u8")])]),t._v(" "),v("tr",[v("td",[t._v("float")]),t._v(" "),v("td",[t._v("r4")])]),t._v(" "),v("tr",[v("td",[t._v("double")]),t._v(" "),v("td",[t._v("r8")])]),t._v(" "),v("tr",[v("td",[t._v("IntPtr")]),t._v(" "),v("td",[t._v("i4")])]),t._v(" "),v("tr",[v("td",[t._v("UintPtr")]),t._v(" "),v("td",[t._v("u4")])]),t._v(" "),v("tr",[v("td",[t._v("enum")]),t._v(" "),v("td",[t._v("underlying类型对应的 Universal32签名")])]),t._v(" "),v("tr",[v("td",[t._v("值类型引用及class类型")]),t._v(" "),v("td",[t._v("i4")])]),t._v(" "),v("tr",[v("td",[t._v("值类型")]),t._v(" "),v("td",[t._v("{S,C}{size}")])])])]),t._v(" "),v("p",[t._v("S,C 分别对应aligment=1、8的值类型。例如UnityEngine.Vector3的签名为S12。")]),t._v(" "),v("h3",{attrs:{id:"universal64-的共享规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#universal64-的共享规则"}},[t._v("#")]),t._v(" Universal64 的共享规则")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("类型")]),t._v(" "),v("th",[t._v("签名")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("bool、byte")]),t._v(" "),v("td",[t._v("u1")])]),t._v(" "),v("tr",[v("td",[t._v("sbyte")]),t._v(" "),v("td",[t._v("i1")])]),t._v(" "),v("tr",[v("td",[t._v("short")]),t._v(" "),v("td",[t._v("i2")])]),t._v(" "),v("tr",[v("td",[t._v("ushort、char")]),t._v(" "),v("td",[t._v("u2")])]),t._v(" "),v("tr",[v("td",[t._v("int")]),t._v(" "),v("td",[t._v("i4")])]),t._v(" "),v("tr",[v("td",[t._v("uint")]),t._v(" "),v("td",[t._v("u4")])]),t._v(" "),v("tr",[v("td",[t._v("long")]),t._v(" "),v("td",[t._v("i8")])]),t._v(" "),v("tr",[v("td",[t._v("ulong")]),t._v(" "),v("td",[t._v("u8")])]),t._v(" "),v("tr",[v("td",[t._v("float")]),t._v(" "),v("td",[t._v("r4")])]),t._v(" "),v("tr",[v("td",[t._v("double")]),t._v(" "),v("td",[t._v("r8")])]),t._v(" "),v("tr",[v("td",[t._v("IntPtr")]),t._v(" "),v("td",[t._v("i4")])]),t._v(" "),v("tr",[v("td",[t._v("UintPtr")]),t._v(" "),v("td",[t._v("u4")])]),t._v(" "),v("tr",[v("td",[t._v("enum")]),t._v(" "),v("td",[t._v("underlying类型对应的 Universal32签名")])]),t._v(" "),v("tr",[v("td",[t._v("值类型")]),t._v(" "),v("td",[t._v("S{size)}")])]),t._v(" "),v("tr",[v("td",[t._v("Vector2f")]),t._v(" "),v("td",[t._v("v2f")])]),t._v(" "),v("tr",[v("td",[t._v("Vector3f")]),t._v(" "),v("td",[t._v("v3f")])]),t._v(" "),v("tr",[v("td",[t._v("Vector4f")]),t._v(" "),v("td",[t._v("v4f")])]),t._v(" "),v("tr",[v("td",[t._v("Vector2d")]),t._v(" "),v("td",[t._v("v2d")])]),t._v(" "),v("tr",[v("td",[t._v("Vector3d")]),t._v(" "),v("td",[t._v("v3d")])]),t._v(" "),v("tr",[v("td",[t._v("Vector4d")]),t._v(" "),v("td",[t._v("v4d")])])])]),t._v(" "),v("p",[t._v("相比于Univeral32，值类型不区分对齐，全部使用S。")]),t._v(" "),v("h3",{attrs:{id:"arm64-的共享规则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arm64-的共享规则"}},[t._v("#")]),t._v(" Arm64 的共享规则")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("类型")]),t._v(" "),v("th",[t._v("签名")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("bool、byte")]),t._v(" "),v("td",[t._v("u1")])]),t._v(" "),v("tr",[v("td",[t._v("sbyte")]),t._v(" "),v("td",[t._v("i1")])]),t._v(" "),v("tr",[v("td",[t._v("short")]),t._v(" "),v("td",[t._v("i2")])]),t._v(" "),v("tr",[v("td",[t._v("ushort、char")]),t._v(" "),v("td",[t._v("u2")])]),t._v(" "),v("tr",[v("td",[t._v("int")]),t._v(" "),v("td",[t._v("i4")])]),t._v(" "),v("tr",[v("td",[t._v("uint")]),t._v(" "),v("td",[t._v("u4")])]),t._v(" "),v("tr",[v("td",[t._v("long")]),t._v(" "),v("td",[t._v("i8")])]),t._v(" "),v("tr",[v("td",[t._v("ulong")]),t._v(" "),v("td",[t._v("u8")])]),t._v(" "),v("tr",[v("td",[t._v("float")]),t._v(" "),v("td",[t._v("r4")])]),t._v(" "),v("tr",[v("td",[t._v("double")]),t._v(" "),v("td",[t._v("r8")])]),t._v(" "),v("tr",[v("td",[t._v("IntPtr")]),t._v(" "),v("td",[t._v("i4")])]),t._v(" "),v("tr",[v("td",[t._v("UintPtr")]),t._v(" "),v("td",[t._v("u4")])]),t._v(" "),v("tr",[v("td",[t._v("enum")]),t._v(" "),v("td",[t._v("underlying类型对应的 Universal32签名")])]),t._v(" "),v("tr",[v("td",[t._v("值类型引用及class类型")]),t._v(" "),v("td",[t._v("i8")])]),t._v(" "),v("tr",[v("td",[t._v("作为参数的值类型(size<=16)")]),t._v(" "),v("td",[t._v("S16")])]),t._v(" "),v("tr",[v("td",[t._v("作为参数的值类型(size>16)")]),t._v(" "),v("td",[t._v("sr")])]),t._v(" "),v("tr",[v("td",[t._v("作为返回值的值类型")]),t._v(" "),v("td",[t._v("S{size)}")])]),t._v(" "),v("tr",[v("td",[t._v("Vector2f")]),t._v(" "),v("td",[t._v("v2f")])]),t._v(" "),v("tr",[v("td",[t._v("Vector3f")]),t._v(" "),v("td",[t._v("v3f")])]),t._v(" "),v("tr",[v("td",[t._v("Vector4f")]),t._v(" "),v("td",[t._v("v4f")])]),t._v(" "),v("tr",[v("td",[t._v("Vector2d")]),t._v(" "),v("td",[t._v("v2d")])]),t._v(" "),v("tr",[v("td",[t._v("Vector3d")]),t._v(" "),v("td",[t._v("v3d")])]),t._v(" "),v("tr",[v("td",[t._v("Vector4d")]),t._v(" "),v("td",[t._v("v4d")])])])]),t._v(" "),v("h2",{attrs:{id:"hybridclr默认桥接函数集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hybridclr默认桥接函数集"}},[t._v("#")]),t._v(" HybridCLR默认桥接函数集")]),t._v(" "),v("p",[t._v("HybridCLR已经扫描过Unity核心库和常见的第三方库生成了默认的桥接函数集，相关代码文件为 libil2cpp/hybridclr/interpreter/MethodBridge_{abi}.cpp，其中{abi}为Arm64、Universal32或Universal64。")]),t._v(" "),v("h2",{attrs:{id:"自定义桥接函数集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义桥接函数集"}},[t._v("#")]),t._v(" 自定义桥接函数集")]),t._v(" "),v("p",[t._v("实践项目中总会遇到一些aot函数的共享桥接函数不在默认桥接函数集中。因此 "),v("RouterLink",{attrs:{to:"/hybridclr/hybridclr_unity/"}},[t._v("hybridclr_unity package")]),t._v("中提供工具脚本，使用菜单命令 "),v("code",[t._v("HybridCLR/Generate/MethodBridge")]),t._v(" 根据程序集自动生成所有桥接函数。")],1)])}),[],!1,null,null,null);v.default=a.exports}}]);