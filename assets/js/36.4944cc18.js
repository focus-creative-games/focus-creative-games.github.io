(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{356:function(t,l,e){"use strict";e.r(l);var r=e(7),i=Object(r.a)({},(function(){var t=this,l=t._self._c;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"hybridclr打包工作流"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#hybridclr打包工作流"}},[t._v("#")]),t._v(" HybridCLR打包工作流")]),t._v(" "),l("p",[t._v("由于热更新本身的要求以及Unity资源管理的一些限制，对打包工作流需要一些特殊处理，主要分为几部分：")]),t._v(" "),l("ul",[l("li",[t._v("设置UNITY_IL2CPP_PATH环境变量")]),t._v(" "),l("li",[t._v("打包时自动排除热更新assembly")]),t._v(" "),l("li",[t._v("打包时将热更新dll名添加到assembly列表")]),t._v(" "),l("li",[t._v("将打包过程中生成的裁剪后的aot dll拷贝出来，供补充元数据使用")]),t._v(" "),l("li",[t._v("使用Unity的"),l("code",[t._v("PlayerBuildInterface.CompilePlayerScripts")]),t._v("Api编译热更新dll")]),t._v(" "),l("li",[t._v("生成一些打包需要的文件和代码")]),t._v(" "),l("li",[t._v("iOS平台的特殊处理")])]),t._v(" "),l("p",[t._v("我们提供了 "),l("code",[t._v("com.focus-creative-games.hybridclr_unity")]),t._v(" package "),l("a",{attrs:{href:"https://gitee.com/focus-creative-games/hybridclr_unity",target:"_blank",rel:"noopener noreferrer"}},[t._v("gitee(推荐)"),l("OutboundLink")],1),t._v("或"),l("a",{attrs:{href:"https://github.com/focus-creative-games/hybridclr_unity",target:"_blank",rel:"noopener noreferrer"}},[t._v("github"),l("OutboundLink")],1),t._v(" ，其中包含了打包工作流相关的标准工具脚本。")]),t._v(" "),l("p",[t._v("更详细的实现请看源码或者"),l("RouterLink",{attrs:{to:"/hybridclr/hybridclr_unity/"}},[t._v("hybridclr_unity介绍")])],1),t._v(" "),l("h2",{attrs:{id:"打包流程"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#打包流程"}},[t._v("#")]),t._v(" 打包流程")]),t._v(" "),l("ul",[l("li",[t._v("参照"),l("RouterLink",{attrs:{to:"/hybridclr/project_settings/"}},[t._v("HybridCLR配置")]),t._v("进行必要的设置")],1),t._v(" "),l("li",[t._v("运行菜单 "),l("code",[t._v("HybridCLR/Generate/All")]),t._v(" 一键执行必要的生成操作")]),t._v(" "),l("li",[t._v("根据你项目原来的打包流程打包")]),t._v(" "),l("li",[t._v("将"),l("code",[t._v("HybridCLRData/HotUpdateDlls")]),t._v("下的热更新dll按照你们项目的热更新资源打包流程处理")]),t._v(" "),l("li",[t._v("将"),l("code",[t._v("HybridCLRData/AssembliesPostIl2CppStrip")]),t._v("下的AOT dll按照你们项目的热更新资源打包流程处理")])]),t._v(" "),l("h2",{attrs:{id:"设置unity-il2cpp-path环境变量"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#设置unity-il2cpp-path环境变量"}},[t._v("#")]),t._v(" 设置UNITY_IL2CPP_PATH环境变量")]),t._v(" "),l("p",[t._v("相关代码在 "),l("code",[t._v("Editor/BuildProcessors/CheckSettings.cs")]),t._v("中。")]),t._v(" "),l("p",[t._v("脚本根据是否开启HybridCLR，在打包时自动设置或者清除UNITY_IL2CPP_PATH环境变量。")]),t._v(" "),l("h2",{attrs:{id:"打包时自动排除热更新assembly"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#打包时自动排除热更新assembly"}},[t._v("#")]),t._v(" 打包时自动排除热更新assembly")]),t._v(" "),l("p",[t._v("相关代码在 "),l("code",[t._v("Editor/BuildProcessors/FilterHotFixAssemblies.cs")]),t._v("中。")]),t._v(" "),l("p",[t._v("很显然，热更新assembly不应该被il2cpp处理并且编译到最终的包体里。我们处理了"),l("code",[t._v("IFilterBuildAssemblies")]),t._v("回调，\n将热更新dll从build assemblies列表移除。")]),t._v(" "),l("h2",{attrs:{id:"打包时将热更新dll名添加到assembly配置列表"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#打包时将热更新dll名添加到assembly配置列表"}},[t._v("#")]),t._v(" 打包时将热更新dll名添加到assembly配置列表")]),t._v(" "),l("p",[t._v("相关代码在 "),l("code",[t._v("Editor/BuildProcessors/PatchScriptingAssemblyList.cs")]),t._v("中。")]),t._v(" "),l("p",[t._v("对于所有C#类，Assembly.Load后就可以正常使用，但对于MonoBehaviour或者ScriptableObject这种脚本，如果想让挂载在热更新资源上\n脚本正确还原，必须处理Unity的资源管理机制相关的问题。")]),t._v(" "),l("p",[t._v("简单来说，热更新MonoBehaviour脚本所在的assembly的dll名必须添加到assembly列表配置文件，Unity的资源管理系统才能正确识别\n和还原脚本。更详细的原理介绍请看 "),l("RouterLink",{attrs:{to:"/hybridclr/monobehaviour/"}},[t._v("使用热更新MonoBehaviour")]),t._v(" 。")],1),t._v(" "),l("p",[t._v("工具在打包时，会自动将热更新assembly的dll名加入assembly列表配置文件。")]),t._v(" "),l("h2",{attrs:{id:"备份裁剪后的aot-dll"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#备份裁剪后的aot-dll"}},[t._v("#")]),t._v(" 备份裁剪后的AOT dll")]),t._v(" "),l("p",[t._v("相关代码在 "),l("code",[t._v("Editor/BuildProcessors/CopyStrippedAOTAssemblies.cs")]),t._v("中。")]),t._v(" "),l("p",[t._v("为了解决AOT泛型问题，我们使用了一个HybridCLR独创的专利技术"),l("code",[t._v("补充元数据技术")]),t._v("。该技术需要提供裁剪后的AOT dll来解决\nil2cpp IL->c++转换过程中函数体元数据丢失的问题。")]),t._v(" "),l("p",[t._v("总之，为了无限制地使用AOT泛型，需要获得打包时生成的裁剪后的AOT dll。脚本会打包过程中生成的裁剪后的AOT dll\n自动复制到 "),l("code",[t._v("HybridCLRData/AssembliesPostIl2CppStrip/{platform}")]),t._v("目录，方便将来处理。")]),t._v(" "),l("p",[t._v("项目既可以选择将裁减后的AOT dll文件直接放主包的StreamingAssets目录，也可以选择打包后热更下载，自己视喜好灵活处理。")]),t._v(" "),l("p",[t._v("更详细的原理性文档请看 "),l("RouterLink",{attrs:{to:"/hybridclr/aot_generic/"}},[t._v("AOT泛型原理")])],1),t._v(" "),l("h2",{attrs:{id:"使用unity的playerbuildinterface-compileplayerscriptsapi编译热更新dll"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#使用unity的playerbuildinterface-compileplayerscriptsapi编译热更新dll"}},[t._v("#")]),t._v(" 使用Unity的"),l("code",[t._v("PlayerBuildInterface.CompilePlayerScripts")]),t._v("Api编译热更新dll")]),t._v(" "),l("p",[t._v("相关代码在 "),l("code",[t._v("Editor/Commands/CompileDllCommand.cs")]),t._v(" 中。")]),t._v(" "),l("p",[t._v("对于每个target，必须使用目标平台编译开关下编译出的热更新dll，否则会出现热更新代码与AOT主包或者热更新资源的代码信息不匹配的情况。")]),t._v(" "),l("p",[t._v("不匹配时Unity会打印此类日志： "),l("code",[t._v("A scripted object (probably XXX?) has a different serialization layout when loading. Did you #ifdef UNITY_EDITOR a section of your serialized properties in any of your scripts?")]),t._v("。")]),t._v(" "),l("h2",{attrs:{id:"生成打包需要的文件和代码"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#生成打包需要的文件和代码"}},[t._v("#")]),t._v(" 生成打包需要的文件和代码")]),t._v(" "),l("p",[t._v("包含以下几个生成功能：")]),t._v(" "),l("ul",[l("li",[t._v("扫描生成link.xml")]),t._v(" "),l("li",[t._v("生成桥接函数")]),t._v(" "),l("li",[t._v("生成AOT泛型实例化代码")]),t._v(" "),l("li",[t._v("生成ReversePInvokeCallback相关wrapper文件")])]),t._v(" "),l("p",[t._v("菜单"),l("code",[t._v("HybridCLR/Generate/*")]),t._v("中包含了这些生成命令，详细介绍请看"),l("RouterLink",{attrs:{to:"/hybridclr/hybridclr_unity/"}},[t._v("hybridclr_unity介绍")])],1),t._v(" "),l("h3",{attrs:{id:"生成link-xml"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#生成link-xml"}},[t._v("#")]),t._v(" 生成link.xml")]),t._v(" "),l("p",[t._v("热更新dll中可能使用到一些主工程代码中未使用的类和函数，而Unity有"),l("a",{attrs:{href:"https://docs.unity3d.com/Manual/ManagedCodeStripping.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("代码裁剪机制"),l("OutboundLink")],1),t._v("。\n如果不使用一些办法避免热更新中用到的主工程类和函数被裁剪，运行时出现 LoadTypeException或者 MethodNotFoundException之类的错误。")]),t._v(" "),l("p",[t._v("解决办法是配置link.xml文件来避免裁剪。手写link.xml麻烦又易遗漏，因此提供了脚本自动生成link.xml。")]),t._v(" "),l("p",[t._v("注意，自动生成的link.xml只是扫描了当前热更新dll用到的AOT类型，它不可能知道未来热更新dll中用到的类型，因此手动在"),l("code",[t._v("Assets/link.xml")]),t._v("（或其他非自动生成的link.xml）中预留\n将来会用到的类型和函数是很有必要的。")]),t._v(" "),l("h3",{attrs:{id:"生成桥接函数"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#生成桥接函数"}},[t._v("#")]),t._v(" 生成桥接函数")]),t._v(" "),l("p",[t._v("为了解决AOT与interpreter之间双向参数传递，需要借助桥接函数。具体原理请看 "),l("RouterLink",{attrs:{to:"/hybridclr/method_bridge/"}},[t._v("桥接函数介绍")]),t._v("。桥接函数需要在正式打包前生成。")],1),t._v(" "),l("p",[t._v("注意！1.0.x及更低版本的hybridclr_unity的桥接函数错误地扫描了editor版本的dll，而editor版本 dll与实际导出的平台的相应dll并不完全相同，导致桥接函数计算与最终打包出的AOT里的不完全一致。1.1.0及更高版本hybridclr_unity修复了桥接函数生成的问题，但需要提前生成裁剪后的aot dll。")]),t._v(" "),l("p",[t._v("因此如果你使用 1.1.0 以上版本的package，在执行"),l("code",[t._v("HybridCLR/generate/all")]),t._v("之前需要额外先执行以下操作：")]),t._v(" "),l("ul",[l("li",[t._v("运行 "),l("code",[t._v("HybridCLR/generate/LinkXml")])]),t._v(" "),l("li",[t._v("build settings中临时打包一次（或者导出工程也行），生成裁剪aot dll")])]),t._v(" "),l("p",[t._v("如果是1.0.x或更低版本，不需要这些操作，操作也无效（带来的代价是极罕见情况下会有桥接函数缺失的问题）。")]),t._v(" "),l("h3",{attrs:{id:"生成aot泛型实例化代码"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#生成aot泛型实例化代码"}},[t._v("#")]),t._v(" 生成AOT泛型实例化代码")]),t._v(" "),l("p",[t._v("Unity有泛型共享机制，对于泛型如果提前在AOT中泛型实例化，脚本中调用该类型相关函数时以原生方式执行。")]),t._v(" "),l("p",[t._v("尽管有补充元数据机制，对于一些性能敏感的代码，提前泛型实例化可以明显提升性能。更详细的原理性文档请看 "),l("RouterLink",{attrs:{to:"/hybridclr/aot_generic/"}},[t._v("AOT泛型原理")])],1),t._v(" "),l("h3",{attrs:{id:"生成reversepinvokecallback相关wrapper文件"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#生成reversepinvokecallback相关wrapper文件"}},[t._v("#")]),t._v(" 生成ReversePInvokeCallback相关wrapper文件")]),t._v(" "),l("p",[t._v("如果项目中用于xlua之类的脚本语言，对于要注册到lua中的C#函数，都需要添加"),l("code",[t._v("[MonoPInvokeCallback]")]),t._v("注解。这样可以为这些C#函数返回一个对应的c++\n函数指针，用于注册到脚本语言里。")]),t._v(" "),l("p",[t._v("HybridCLR支持将热更新C#代码注册到lua中，但必须提前生成与"),l("code",[t._v("[MonoPInvokeCallback]")]),t._v("对应的C++桩函数，才可能为每个C#函数返回一个相应的C++函数指针。\n脚本提供了自动生成桩函数的功能。详细请见 "),l("RouterLink",{attrs:{to:"/hybridclr/monopinvokecallback/"}},[t._v("MonoPInvokeCallback支持")]),t._v(" 及 "),l("RouterLink",{attrs:{to:"/hybridclr/work_with_script_language/"}},[t._v("HybridCLR+lua/js/python")]),t._v(" 文档")],1),t._v(" "),l("h2",{attrs:{id:"ios平台的特殊处理"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#ios平台的特殊处理"}},[t._v("#")]),t._v(" iOS平台的特殊处理")]),t._v(" "),l("p",[t._v("除了iOS以外平台都是将 "),l("code",[t._v("libil2cpp源码")]),t._v(" 和 "),l("code",[t._v("由il2cpp从原始dll转换成的c++代码")]),t._v(" 直接源码编译出目标程序。iOS\n平台比较特殊，它使用由"),l("code",[t._v("libil2cpp源码")]),t._v("提前编译好libil2cpp.a文件，和 "),l("code",[t._v("由il2cpp从原始dll转换成的c++代码")]),t._v(" 链接，\n编译出目标程序。Unity导出的xcode工程包含了提前生成好的libil2cpp.a，而不包含libil2cpp源码。")]),t._v(" "),l("p",[t._v("因此编译iOS程序时需要自己单独编译libil2cpp.a，再替换xcode工程的相应文件，最终再打包出app。")]),t._v(" "),l("p",[t._v("编译方法参见"),l("RouterLink",{attrs:{to:"/hybridclr/build_ios_libil2cpp/"}},[t._v("编译iOS版本libil2cpp")]),t._v("。替换xcode工程中相应文件请自己手动完成。")],1)])}),[],!1,null,null,null);l.default=i.exports}}]);