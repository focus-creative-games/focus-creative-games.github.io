(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{367:function(r,t,a){"use strict";a.r(t);var s=a(7),v=Object(s.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"faq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#faq"}},[r._v("#")]),r._v(" FAQ")]),r._v(" "),t("h2",{attrs:{id:"hybridclr支持哪些平台"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hybridclr支持哪些平台"}},[r._v("#")]),r._v(" HybridCLR支持哪些平台?")]),r._v(" "),t("p",[r._v("il2cpp支持的平台都支持")]),r._v(" "),t("h2",{attrs:{id:"hybridclr会增加多大的包体"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hybridclr会增加多大的包体"}},[r._v("#")]),r._v(" HybridCLR会增加多大的包体")]),r._v(" "),t("p",[r._v("以 2019版本为例，release模式下导出Android工程的libil2cpp.a文件， 原始版本12.69M，HybridCLR版本13.97M，也就是增加了大约1.3M。")]),r._v(" "),t("h2",{attrs:{id:"为什么使用hybridclr打出的包体增大很多"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用hybridclr打出的包体增大很多"}},[r._v("#")]),r._v(" 为什么使用HybridCLR打出的包体增大很多")]),r._v(" "),t("p",[r._v("HybridCLR本身只会增加很少包体(1-2M)。包体增大很多是因为你错误地在link.xml保留了太多类，导致包体急剧增大。")]),r._v(" "),t("p",[r._v("请自行参照Unity的裁剪规则优化。")]),r._v(" "),t("h2",{attrs:{id:"hybridclr是嵌了mono吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hybridclr是嵌了mono吗"}},[r._v("#")]),r._v(" HybridCLR是嵌了mono吗？")]),r._v(" "),t("p",[r._v("不是。HybridCLR给il2cpp补充了完全独立自主实现的完整的寄存器解释器。")]),r._v(" "),t("h2",{attrs:{id:"hybridclr写代码有什么限制吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hybridclr写代码有什么限制吗"}},[r._v("#")]),r._v(" HybridCLR写代码有什么限制吗？")]),r._v(" "),t("p",[r._v("几乎没有限制，参见"),t("RouterLink",{attrs:{to:"/hybridclr/limit/"}},[r._v("限制事项")])],1),r._v(" "),t("h2",{attrs:{id:"支持泛型类和泛型函数吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持泛型类和泛型函数吗"}},[r._v("#")]),r._v(" 支持泛型类和泛型函数吗？")]),r._v(" "),t("p",[r._v("彻底完整的支持，无任何限制。")]),r._v(" "),t("h2",{attrs:{id:"支持热更新monobehaviour吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持热更新monobehaviour吗"}},[r._v("#")]),r._v(" 支持热更新MonoBehaviour吗？")]),r._v(" "),t("p",[r._v("完全支持。不仅能在代码中添加，也可以直接挂在热更新资源上。具体参见"),t("RouterLink",{attrs:{to:"/hybridclr/monobehaviour/"}},[r._v("使用热更新MonoBehaviour")])],1),r._v(" "),t("h2",{attrs:{id:"支持反射吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持反射吗"}},[r._v("#")]),r._v(" 支持反射吗？")]),r._v(" "),t("p",[r._v("支持， 无任何限制。")]),r._v(" "),t("h2",{attrs:{id:"对多线程支持如何"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对多线程支持如何"}},[r._v("#")]),r._v(" 对多线程支持如何？")]),r._v(" "),t("p",[r._v("完整支持。 支持Thread, Task, volatile, ThreadStatic, async。")]),r._v(" "),t("h2",{attrs:{id:"支持多assembly吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持多assembly吗"}},[r._v("#")]),r._v(" 支持多Assembly吗？")]),r._v(" "),t("p",[r._v("支持,最大支持255个。但是不会自动加载依赖dll。需要你手动按依赖顺序加载热更dll。")]),r._v(" "),t("h2",{attrs:{id:"支持创建值类型吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持创建值类型吗"}},[r._v("#")]),r._v(" 支持创建值类型吗？")]),r._v(" "),t("p",[r._v("支持。")]),r._v(" "),t("h2",{attrs:{id:"支持-net-standard-2-0-吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持-net-standard-2-0-吗"}},[r._v("#")]),r._v(" 支持 .net standard 2.0 吗？")]),r._v(" "),t("p",[r._v("支持。但请注意，主工程打包用.net standard，而热更新dll打包"),t("strong",[r._v("必须用.net 4.x")]),r._v("。详细解释请参照"),t("RouterLink",{attrs:{to:"/hybridclr/common_errors/"}},[r._v("常见错误文档")])],1),r._v(" "),t("h2",{attrs:{id:"支持unity的dots框架吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#支持unity的dots框架吗"}},[r._v("#")]),r._v(" 支持Unity的DOTS框架吗？")]),r._v(" "),t("p",[r._v("支持。AOT部分的burst代码工作正常，但热更新部分的burst代码以解释方式执行。这个是显然的。")]),r._v(" "),t("h2",{attrs:{id:"methodbridge生成非常耗时-每次打包都需要重新生成吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#methodbridge生成非常耗时-每次打包都需要重新生成吗"}},[r._v("#")]),r._v(" MethodBridge生成非常耗时，每次打包都需要重新生成吗")]),r._v(" "),t("p",[r._v("桥接函数在版本间变化不大，而且 "),t("code",[r._v("interpreter -> AOT")]),r._v(" 方面的桥接函数有反射托底，很少会出现缺失的情况。")]),r._v(" "),t("p",[r._v("因此开发期只要没遇到桥接函数缺失的情况，可以不用再生成，但打正式包，强烈推荐生成一次。")])])}),[],!1,null,null,null);t.default=v.exports}}]);