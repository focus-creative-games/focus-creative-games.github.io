---
title: Load and use hot update code
date: 2022-09-29 12:31:29
permalink: /hybridclr/load_assembly/
categories:
  - hybridclr
  - 文档
tags:
  - 
author: 
  name: walon
  link: https://github.com/focus-creative-games
---

# Load and use hot update code

## Compile hot update dll

For developers whose hot update code is placed in a third-party project, just use your own method to compile the hot update dll.

For developers whose hot update code is placed in the Unity project, you cannot directly copy the dll in the `Library/ScriptAssemblies` directory,
This is because the correct platform macro switch is required when compiling the code, and the dll under `Library/ScriptAssemblies` is compiled using the Editor platform macro, which does not meet the requirements.

When Unity is packaged, it will automatically help you compile the dll with the correct macro switch, but this is troublesome and time-consuming. A better way is to use Unity's `PlayerBuildInterface.CompilePlayerScripts`Api to complete the compilation.

Hybridclr_unity provides a compilation script for compiling hot update dll corresponding to each target. Use the menu `HybridCLR/CompileDll/xxxx` to compile the hot update for your desired platform
dll, the hot update dll after compilation is placed in the `{project}/HybridCLRData/HotUpdateDlls/{platform}` directory.

## Add hot update dll to your hot update resource management system

The `{project}/HybridCLRData/HotUpdateDlls/{platform}` directory can get the hot update dll, which can be processed according to the situation of your own project, which can be entered into the ab package or bare data.

For the convenience of demonstration, the hybridclr_trial project directly renames Assembly-CSharp.dll to Assembly-CSharp.dll.bytes and puts it into the StreamingAssets directory.

## Load update assembly

According to your project resource management method, get the bytes data of the hot update dll. Then directly call Assembly.Load(byte[] assemblyData) to load the hot update dll. code like
as follows:

```csharp
    byte[] assemblyData = xxxx; // 从你的资源管理系统中获得热更新dll的数据
    Assembly ass = Assembly.Load(assemblyData);
```

If there are multiple hot update dlls, be sure to load them in the order of dependencies, and load the dependent assembly first.

## Run hot update code

After loading the hot update dll, there are many ways to run the hot update code, which is no special difference from your regular c# code.

### Run via reflection

Assuming that there is a HotUpdateEntry class in the hot update set, the main entry is a static Main function, and the code is similar:

```csharp
class HotUpdateEntry
{
    public static void Main()
    {
        UnityEngine.Debug.Log("hello, HybridCLR");
    }
}
```


You run it like this:

```csharp
    // ass 为Assembly.Load返回的热更新assembly。
    // 你也可以在Assembly.Load后通过类似如下代码查找获得。
    // Assembly ass = AppDomain.CurrentDomain.GetAssemblies().First(assembly => assembly.GetName().Name == "Assembly-CSharp");
    Type entryType = ass.GetType("HotUpdateEntry");
    MethodInfo method = entryType.GetMethod("Main");
    method.Invoke(null, null);
```

### Run after creating a Delegate through reflection

```csharp
    Type entryType = ass.GetType("HotUpdateEntry");
    MethodInfo method = entryType.GetMethod("Main");
    Action mainFunc = (Action)Delegate.CreateDelegate(typeof(Action), method);
    mainFunc();
```

### After creating the object through reflection, call the interface function

Suppose there is such an interface in AOT

```csharp
public interface IEntry
{
    void Start();
    void Update(float deltaTime);
}
```

Such a class is implemented in hot update

```csharp
class HotUpdateEntry : IEntry
{
    public void Start()
    {
        UnityEngine.Debug.Log("hello, HybridCLR");
    }

    public void Update(float deltaTime)
    {

    }
}
```

You run it like this:

```csharp
    Type entryType = ass.GetType("HotUpdateEntry");
    IEntry entry = (IEntry)Activator.CreateInstance(entryType);
    entry.Start();
```

### Mount the scene or prefab of the hot update script by direct initialization

Assuming that there is such an entry script in the hot update, this script is hung on `HotUpdatePrefab.prefab`.

```csharp

public class HotUpdateMain : MonoBehaviour
{
    void Start()
    {
        Debug.Log("hello, HybridCLR");
    }
}

```

You can run hot update logic by instantiating this prefab.

```csharp
        AssetBundle prefabAb = xxxxx; // 获得HotUpdatePrefab.prefab所在的AssetBundle
        GameObject testPrefab = Instantiate(prefabAb.LoadAsset<GameObject>("HotUpdatePrefab.prefab"));
```

This method does not require any reflection and is very similar to the native startup workflow, highly recommended!

In practice, after the hot update is completed, the hot update logic is directly entered by directly switching to the hot update scene, with minimal changes to the old project.

