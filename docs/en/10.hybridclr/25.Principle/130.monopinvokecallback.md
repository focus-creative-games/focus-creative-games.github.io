---
title: MonoPInvokeCallback Support
date: 2022-05-25 11:50:18
permalink: /hybridclr/monopinvokecallback/
categories:
    - HybridCLR
tags:
    -
author:
    name: walon
    link: https://github.com/pirunxi
---


# MonoPInvokeCallbackAttribute support

HybridCLR's support for `MonoPInvokeCallbackAttribute` is exactly the same as native. Since each function marked `MonoPInvokeCallbackAttribute` has a unique corresponding c++ function, and AOT restrictions make it impossible to add functions at runtime, so the Wrapper c++ function must be pre-generated in advance for binding with the `MonoPInvokeCallbackAttribute` function.

These wrapper functions are in `hybridclr/generated/ReversePInvokeMethodStub_{abi}.cpp` file.

[hybridclr_unity](/en/hybridclr/hybridclr_unity/) has provided scripts to help automatically generate these wrapper functions, just run the menu command `HybridCLR/Generate/ReversePInvokeWrapper`.

## Reserved ReversePInvokeWrapper function

If you only generate the same number of wrapper functions as the current functions with the `MonoPInvokeCallbackAttribute` feature, and add hot update functions later, then
The problem of insufficient wrapper functions will occur. The solution is to use `HybridCLR.ReversePInvokeWrapperGenerationAttribute` for reserved operations.

Add a feature `[ReversePInvokeWrapperGeneration(int preserveCount)]` to the function with `MonoPInvokeCallbackAttribute`, and generate preserveCount wrapper functions for the function of this signature. If this attribute is not included, it will only be generated for this function
A wrapper function.

If the `[ReversePInvokeWrapperGeneration(xx)]` attribute is added to multiple functions with the same signature, the total number of wrapper functions is `the sum of all preserveCount + the number of functions that do not contain the ReversePInvokeWrapperGenerationAttribute attribute`.

As shown below, there are 10 wrappers of type `LuaFunction`, 101 wrappers of type `Func<int, int, int>`, and 1 wrapper of type `Func<int, int>`.

```csharp

delegate int LuaFunction(IntPtr luaState);

public class MonoPInvokeWrapperPreserves
{
    [ReversePInvokeWrapperGeneration(10)]
    [MonoPInvokeCallback(typeof(LuaFunction))]
    public static int LuaCallback(IntPtr luaState)
    {
        return 0;
    }

    [ReversePInvokeWrapperGeneration(100)]
    [MonoPInvokeCallback(typeof(Func<int, int, int>))]
    public static int Sum(int a, int b)
    {
        return a + b;
    }

    [MonoPInvokeCallback(typeof(Func<int, int, int>))]
    public static int Sum2(int a, int b)
    {
        return a + b;
    }

    [MonoPInvokeCallback(typeof(Func<int, int>))]
    public static int Inc(int a)
    {
        return a + 1;
    }
}

```

## Limit

At present, there is no marshal processing for reference type parameters. Reference type parameters such as string are directly passed as parameters, which will inevitably lead to a crash after use!
Please use simple primitive types such as int and float. If there is such a need, you can put the callback function in the AOT, and call back the hot update in the AOT
function.