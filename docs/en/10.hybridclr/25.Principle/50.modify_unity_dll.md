---
title: Modify Unity editor related dll
date: 2022-05-29 20:55:59
permalink: /hybridclr/modify_unity_dll/
categories:
  - HybridCLR
tags:
  - 
author: 
  name: Code Philosophy
  link: https:://code-philosophy.com
---

# Modify Unity editor related dll

Since the Editor script and il2cpp tool provided by Unity cannot fully meet the requirements, in some Unity versions or packaged with certain target platforms, it is necessary to update the Unity Editor
Some dlls that come with it are modified.

There are currently two dlls that have been modified:

- UnityEditor.CoreModule.dll
- Unity.IL2CPP.dll

Note that not all versions and platforms need to modify these two dlls, as detailed below.

## Use the dnspy tool

We use [dnspy](https://github.com/dnSpy/dnSpy) to modify dll files. And dnspy can only run under Win, so even if it is a mac version dll,
You also have to copy the corresponding dll to Win and then modify it.

Download [dnspy](https://github.com/dnSpy/dnSpy/releases), select [Win64 version](https://github.com/dnSpy/dnSpy/releases/download/v6.1.8/dnSpy-net-win64.zip).

The operation of modifying the dll is roughly as follows:

- Clear all dlls on the left in dnspy
- open dll
- Find the function you want to modify `ToModifiedType.ToModifiedMethod` function, right-click the menu -> Edit Method (c#)..., and the source code editing interface will pop up.
- If the editor prompts that some dll references are missing, click the button similar to a folder in the lower left corner of the source code editing window to add them.
- modify the code
- Click the `Compile` button in the lower right corner. If it is successful, there will be no prompt, exit the editing interface, and return to the decompilation viewing mode. If that fails, handle compilation errors yourself. Sometimes dnspy will have inexplicable reference errors, exit the source code editing mode, right-click `edit method` again, and enter again to solve it.
- Menu `File -> Save Module` to save the modified dll file. If under Win or Mac, you may encounter permission problems, please handle it accordingly (for example, save it to another location first, and then manually overwrite it)

## UnityEditor.CoreModule.dll

Only developers who need to build iOS in version 2021 need to use the modified version of UnityEditor.CoreModule.dll.

### Principle

The `HomologousImageMode::Consistent` mode of the `Supplementary Metadata` technology needs to use the cropped AOT dll. At this time, we need to obtain the AOT dll generated during the packaging process.

For Unity 2020 and earlier versions, copy out the trimmed AOT dll in the `IIl2CppProcessor.OnBeforeConvertRun` event.

For the Unity 2021 version, targets other than iOS can copy the AOT dll in the `IPostprocessBuildWithReport.OnPostprocessBuild` event.

But when the target is iOS, the clipping output directory is very different from others, it is `Temp/StagingArea/Data/Managed/tempStrip`, and Unity will delete this temporary directory after converting to c++ code.

Unity Editor does not provide a public interface to copy the AOT dll when the target is iOS, so you can only modify the code of UnityEditor.CoreModule.dll. After generating and cutting the AOT dll, insert the appropriate code and copy the corresponding dll to `HybridCLRData\AssembliesPostIl2CppStrip \iOS`, for subsequent packaging.

The UnityEditor.CoreModule.dll code is different for each Unity version. Due to our limited time, only versions 2021.3.1 and 2021.3.6 are currently available (more may be provided in the future), please make other versions yourself. See the section `Modify UnityEditor.CoreModule.dll` for the specific operation method.

Notice! The same version of Win and Mac version of UnityEditor.CoreModule.dll cannot be mixed and must be produced separately.

### Replace the original UnityEditor.CoreModule.dll

- Back up `{Editor installation directory}/Editor/Data/Managed/UnityEngine/UnityEditor.CoreModule.dll` in advance. The specific location of UnityEditor.CoreModule.dll may vary depending on the operating system or Unity version.
- If you happen to be using a version of 2021.3.1 that already provides a prepared dll, use `com.focus-creative-games.hybridclr_unity/Datas~/ModifiedUnityAssemblies/{version}/UnityEditor.CoreModule-{Win,MAC} .dll` overrides UnityEditor.CoreModule.dll in the Editor installation directory.


### Modify with dnspy

Before performing the following operations, you should carefully read the previous section `Using the dnspy tool`.

- Copy the `{Editor installation directory}/Editor/Data/Managed/UnityEngine` directory, assuming it is the TempUnityEngine directory
- Delete all .pdb type debug files under the TempUnityEngine directory. **Because there is a problem with Unity's pdb file, it will cause dnspy parsing errors, resulting in failure to save.**
- Open dnspy, clear the dll list on the left.
- Open `TempUnityEngine/UnityEditor.CoreModule.dll` with dnspy
- Open the `UnityEditorInternal.AssemblyStripper.RunAssemblyStripper` function, right-click menu -> Edit method (c#)..., and the source code editing interface will pop up.
- At this time, the editor lacks the reference of mscorlib.dll, which needs to be added manually. Click the button similar to the folder in the lower left corner of the source code editing window, and add `{Editor installation directory}/Editor/Data/UnityReferenceAssemblies/unity-4.8-api/mscorlib.dll`.
- At the end of the `RunAssemblyStripper` function, find this code block
  
```csharp
	foreach (string text3 in Directory.GetFiles(fullPath))
	{
		File.Move(text3, Path.Combine(managedAssemblyFolderPath, Path.GetFileName(text3)));
	}
```
修改为 
```csharp
	string dstAOTDir = Path.Combine(UnityEngine.Application.dataPath, "../HybridCLRData/AssembliesPostIl2CppStrip", EditorUserBuildSettings.activeBuildTarget.ToString());
	Directory.CreateDirectory(dstAOTDir);
	foreach (string text3 in Directory.GetFiles(fullPath))
	{
		if (text3.EndsWith(".dll"))
		{
			string copyDstFile = Path.Combine(dstAOTDir, Path.GetFileName(text3));
			File.Copy(text3, copyDstFile, true);
			UnityEngine.Debug.Log("[RunAssemblyStripper] copy aot dll " + text3 + " -> " + copyDstFile);
		}
		File.Move(text3, Path.Combine(managedAssemblyFolderPath, Path.GetFileName(text3)));
	}
```

- Note! In the decompiled code, the variable name may not be text3, please handle it according to the actual situation. If you encounter a compilation error, please handle it at your own discretion.
- Click the `Compile` button in the lower right corner. If it is successful, there will be no prompt, exit the editing interface, and return to the decompilation viewing mode. If that fails, handle compilation errors yourself. Sometimes dnspy will have inexplicable reference errors, exit the source code editing mode, right-click `edit method` again, and enter again to solve it.
- Menu `File -> Save Module` to save the modified UnityEditor.CoreModule.dll file. If under Win or Mac, you may encounter permission problems, please handle it accordingly (for example, save it to another location first, and then manually overwrite it)
- Reopen the Unity Editor. At this point iOS can correctly get the cropped AOT dll.

## Unity.IL2CPP.dll

### Principle

In the 2019 version, we need to slightly modify the code generated by il2cpp, and replace the constant const Il2CppType defined in `Il2CppOutputProject\Source\il2cppOutput\Il2CppTypeDefinitions.c` with a variable Il2CppType. We need to modify the `Unity.IL2CPP.dll` code to achieve this goal.

Notice! During the actual operation, we found that there was a problem with the decompiled code of dnspy. Finally, we adjusted the code based on the decompiled code of ILSpy, and then edited and saved it in dnspy.

Directly copy the modified code below, edit and save it in dnspy. The modification process may encounter problems, refer to the solution used in modifying `UnityEditor.CoreModule.dll` above.

### Unity.IL2CPP.CppDeclarationsWriter::Write(StreamWriter writer, ICppDeclarations declarationsIn, IInteropDataCollector interopDataCollector)

modified code

```csharp
     string[] includesToSkip = new string[3] { "\"il2cpp-config.h\"", "<alloca.h>", "<malloc.h>" };
    CppDeclarationsCollector.PopulateCache(declarationsIn.TypeIncludes, cache, interopDataCollector);
    HashSet<TypeReference> hashSet = new HashSet<TypeReference>(declarationsIn.TypeIncludes, new TypeReferenceEqualityComparer());
    ReadOnlyHashSet<TypeReference> dependencies = CppDeclarationsCollector.GetDependencies(declarationsIn.TypeIncludes, cache);
    hashSet.UnionWith(dependencies);
    ReadOnlyCollection<TypeReference> readOnlyCollection = hashSet.ToSortedCollection(new CppIncludeDepthComparer(comparer));
    CppDeclarations cppDeclarations = new CppDeclarations();
    cppDeclarations.Add(declarationsIn);
    foreach (TypeReference item in readOnlyCollection)
    {
        cppDeclarations.Add(cache.GetDeclarations(item));
    }
    writer.WriteLine();
    foreach (string rawFileLevelPreprocessorStmt in cppDeclarations.RawFileLevelPreprocessorStmts)
    {
        writer.WriteLine(rawFileLevelPreprocessorStmt);
    }
    writer.WriteLine();
    foreach (string item2 in cppDeclarations.Includes.Where((string i) => !includesToSkip.Contains(i) && i.StartsWith("<")))
    {
        writer.WriteLine("#include {0}", item2);
    }
    writer.WriteLine();
    foreach (string item3 in cppDeclarations.Includes.Where((string i) => !includesToSkip.Contains(i) && !i.StartsWith("<")))
    {
        writer.WriteLine("#include {0}", item3);
    }
    writer.WriteLine();
    WriteVirtualMethodDeclaration(writer, cppDeclarations.VirtualMethods);
    writer.WriteLine();
    foreach (TypeReference item4 in cppDeclarations.ForwardDeclarations.ToSortedCollection())
    {
        if (!item4.IsSystemObject() && !item4.IsSystemArray())
        {
            if (CodeGenOptions.EmitComments)
            {
                writer.WriteLine(Emit.Comment(item4.FullName));
            }
            writer.WriteLine("struct {0};", Globals.Naming.ForType(item4));
        }
    }
    writer.WriteLine();
    foreach (string item5 in cppDeclarations.RawTypeForwardDeclarations.ToSortedCollection())
    {
        writer.WriteLine(item5 + ";");
    }
    writer.WriteLine();
    foreach (ArrayType item6 in cppDeclarations.ArrayTypes.ToSortedCollection())
    {
        writer.WriteLine("struct {0};", Globals.Naming.ForType(item6));
    }
    writer.WriteLine();
    writer.WriteLine("IL2CPP_EXTERN_C_BEGIN");
    foreach (TypeReference typeExtern in cppDeclarations.TypeExterns)
    {
        writer.WriteLine("extern Il2CppType " + Globals.Naming.ForIl2CppType(typeExtern) + ";");
    }
    foreach (IList<TypeReference> genericInstExtern in cppDeclarations.GenericInstExterns)
    {
        writer.WriteLine("extern Il2CppGenericInst " + Globals.Naming.ForGenericInst(genericInstExtern) + ";");
    }
    foreach (TypeReference genericClassExtern in cppDeclarations.GenericClassExterns)
    {
        writer.WriteLine("extern Il2CppGenericClass " + Globals.Naming.ForGenericClass(genericClassExtern) + ";");
    }
    writer.WriteLine("IL2CPP_EXTERN_C_END");
    writer.WriteLine();
    if (readOnlyCollection.Count > 0)
    {
        writer.WriteClangWarningDisables();
        foreach (TypeReference item7 in readOnlyCollection)
        {
            string source = cache.GetSource(item7);
            writer.Write(source);
        }
        writer.WriteClangWarningEnables();
    }
    foreach (ArrayType arrayType in cppDeclarations.ArrayTypes)
    {
        TypeDefinitionWriter.WriteArrayTypeDefinition(arrayType, new CodeWriter(writer));
    }
    writer.WriteLine();
    foreach (string rawMethodForwardDeclaration in cppDeclarations.RawMethodForwardDeclarations)
    {
        writer.WriteLine(rawMethodForwardDeclaration + ";");
    }
    writer.WriteLine();
    foreach (MethodReference sharedMethod in cppDeclarations.SharedMethods)
    {
        WriteSharedMethodDeclaration(writer, sharedMethod);
    }
    writer.WriteLine();
    foreach (MethodReference method in cppDeclarations.Methods)
    {
        WriteMethodDeclaration(writer, method);
    }
    writer.Flush();
```

### Unity.IL2CPP.Il2CppTypeWriter::WriteIl2CppTypeDefinitions(IMetadataCollection metadataCollection)

modified code:

```csharp
    base.Writer.AddCodeGenMetadataIncludes();
    IDictionary<Il2CppTypeData, int> items = Globals.Il2CppTypeCollectorReader.Items;
    foreach (IGrouping<TypeReference, Il2CppTypeData> item in items.Keys.GroupBy((Il2CppTypeData entry) => entry.Type.GetNonPinnedAndNonByReferenceType(), new TypeReferenceEqualityComparer()))
    {
        base.Writer.WriteLine();
        TypeReference key = item.Key;
        GenericParameter genericParameter = key as GenericParameter;
        GenericInstanceType genericInstanceType = key as GenericInstanceType;
        ArrayType arrayType = key as ArrayType;
        PointerType pointerType = key as PointerType;
        string text = ((genericParameter != null) ? ("(void*)" + metadataCollection.GetGenericParameterIndex(genericParameter)) : ((genericInstanceType != null) ? WriteGenericInstanceTypeDataValue(genericInstanceType, metadataCollection) : ((arrayType != null) ? WriteArrayDataValue(arrayType) : ((pointerType == null) ? ("(void*)" + metadataCollection.GetTypeInfoIndex(key.Resolve()).ToString(CultureInfo.InvariantCulture)) : WritePointerDataValue(pointerType)))));
        foreach (Il2CppTypeData item2 in item)
        {
            base.Writer.WriteLine("extern Il2CppType {0};", Globals.Naming.ForIl2CppType(item2.Type, item2.Attrs));
            base.Writer.WriteLine("Il2CppType {0} = {{ {1}, {2}, {3}, {4}, {5}, {6} }};", Globals.Naming.ForIl2CppType(item2.Type, item2.Attrs), text, item2.Attrs.ToString(CultureInfo.InvariantCulture), Il2CppTypeSupport.For(item2.Type), "0", item2.Type.IsByReference ? "1" : "0", item2.Type.IsPinned ? "1" : "0");
        }
    }
    return MetadataWriter.WriteTable(base.Writer, "const Il2CppType* const ", "g_Il2CppTypeTable", items.ItemsSortedByValue(), (KeyValuePair<Il2CppTypeData, int> kvp) => "&" + Globals.Naming.ForIl2CppType(kvp.Key.Type, kvp.Key.Attrs), externTable: true);
```

### Unity.IL2CPP.Metadata.Il2CppGenericInstWriter::WriteIl2CppGenericInstDefinitions(IIl2CppGenericInstCollectorReaderService genericInstCollection)

modified code:

```csharp
base.Writer.AddCodeGenMetadataIncludes();
    foreach (TypeReference[] item in genericInstCollection.Items.Select(delegate(KeyValuePair<TypeReference[], uint> item)
    {
        KeyValuePair<TypeReference[], uint> keyValuePair = item;
        return keyValuePair.Key;
    }))
    {
        for (int i = 0; i < item.Length; i++)
        {
            base.Writer.WriteExternForIl2CppType(item[i]);
        }
        string format = "static const Il2CppType* {0}[] = {{ {1} }};";
        WriteLine(format, Globals.Naming.ForGenericInst(item) + "_Types", item.Select((TypeReference t) => MetadataWriter.TypeRepositoryTypeFor(t)).AggregateWithComma());
        WriteLine("extern Il2CppGenericInst {0};", Globals.Naming.ForGenericInst(item));
        WriteLine("Il2CppGenericInst {0} = {{ {1}, {2} }};", Globals.Naming.ForGenericInst(item), item.Length, Globals.Naming.ForGenericInst(item) + "_Types");
    }
    return MetadataWriter.WriteTable(base.Writer, "const Il2CppGenericInst* const", "g_Il2CppGenericInstTable", genericInstCollection.Items.ItemsSortedByValue(), (KeyValuePair<TypeReference[], uint> item) => "&" + Globals.Naming.ForGenericInst(item.Key), externTable: true);
```
