---
title: Introduce hybridclr_unity Package
date: 2022-05-25 11:50:18
permalink: /hybridclr/hybridclr_unity/
categories:
    - HybridCLR
tags:
    -
author:
    name: walon
    link: https://github.com/pirunxi
---

# hybridclr_unity

hybridclr_unity is a Unity package that provides Editor workflow tool scripts and Runtime scripts required by HybridCLR. with the help of
The workflow tool provided by hybridclr_unity makes it very easy to package an App that supports HybridCLR hot update function.


The hybridclr_unity tool mainly includes:

- Editor related scripts
-iOSBuild script
- Runtime related scripts

## Install 

Install `com.focus-creative-games.hybridclr_unity` from git url [gitee (recommended)](https://gitee.com/focus-creative-games/hybridclr_unity) or [github](https://github.com/focus-creative-games/hybridclr_unity) package.

If you are not familiar with installing packages from url, please see [install from giturl](https://docs.unity3d.com/Manual/upm-ui-giturl.html).

Due to domestic network reasons, you may encounter network exceptions in Unity and fail to install. You can clone or download `com.focus-creative-games.hybridclr_unity` to local, and then [install from disk](https://docs.unity3d.com/Manual/upm-ui-local.html).

Or a simpler way, after downloading to the local, rename the warehouse folder directory to `com.focus-creative-games.hybridclr_unity`, and copy it directly to the `Packages` directory of your project.

## HybridCLR menu introduction

### Installer...

A handy installer is provided to help correctly set up the local il2cpp directory, which contains a modified version replacing the `HybridCLRData/LocalIl2CppData-{platform}/il2cpp/libil2cpp` directory with HybridCLR.

The installer needs to copy il2cpp (similar to `C:\Program Files\Unity\Hub\Editor\2020.3.33f1\Editor\Data\il2cpp`) related files from the Unity installation directory of the matching version.

- For 2019.4.40+, 2021.3.25+, 2021.3.0+ versions, copy the il2cpp file directly from the installation directory of that version.
- For 2020.3.16-2020.3.20 versions, 2020.3.26+ versions need to be installed additionally, because the il2cpp files of these versions are not compatible with HybridCLR, but il2cpp of compatible versions (ie 2020.3.26+) can be used.  **Notice! From version 1.1.7, the installer no longer supports installing il2cpp related files from other versions, you can only install them manually according to the principle.**

`Installation Status: Installed | Not Installed` in the installation interface indicates whether HybridCLR initialization is complete.

In the installation interface, the `il2cpp_plus branch corresponds to the il2cpp path of the compatible version of Unity` (**Note! Version 1.1.7 removed this setting.**) Several conditions must be met:

- Must be the il2cpp directory of a compatible unity version
- The path must contain the unity version number (the Installer is used to identify the Unity version, and to prevent novices from choosing the wrong directory)

If the path is legal, the interface will display normally, otherwise a red warning will appear.

Fill in the commit id or branch or tag of the hybridclr and il2cpp_plus warehouses you want to install. If the version number of hybridclr is left blank, install the latest version from the main branch of the hybridclr repository.
If the version number of il2cpp_plus is left blank, install the latest version of the branch of the corresponding annual version (such as 2020.3.33).

Click Install, if successful, the `Installation Successful` log will be displayed at the end, and the installation status will switch to `Installed`, otherwise please check the error log.

If HybridCLR is already installed, clicking the Install button will install the latest HybridCLR version of libil2cpp.

### Compile Dll

For each target, you must use the hot update dll compiled under the compile switch of the target platform, otherwise the hot update code will not match the code information of the AOT main package or hot update resources.

Unity will print this kind of log when there is no match: `A scripted object (probably XXX?) has a different serialization layout when loading. Did you #ifdef UNITY_EDITOR a section of your serialized properties in any of your scripts?`.

With the help of Unity's `PlayerBuildInterface.CompilePlayerScripts` Api, hybridclr_unity provides a compilation script for compiling the hot update dll corresponding to each target. After the compilation is completed, the hot update dll is placed in the `{project}/HybridCLRData/HotUpdateDlls/{platform}` directory.

Developers can flexibly choose the appropriate way to use these hot update dlls.

### Generate

Generate contains a variety of generation tools.

####LinkXml

Scan the AOT type referenced by the hot update dll, generate link.xml, and prevent the AOT type or function used by the hot update script from being clipped. The output file path is specified in the `OuputLinkXml` field in HybridCLRSettings.asset, and the default is `LinkGenerator/link.xml`.

For a more specific introduction to clipping, please see [Code Clipping Principles and Solutions](/hybridclr/code_striping/).

####MethodBridge

Scan and generate bridge function files according to the current AOT dll set. The `maxGenericReferenceIteration` field in HybridCLRSettings.asset specifies the maximum number of iterations for generic recursive scanning. Most items take
Within 10 is enough.

For more specific documents related to bridge functions, please see the [bridge function](/hybridclr/method_bridge/) document.

#### AOTGenericReference

Scan all generated AOT generic types and function instantiations according to the current hot update dll, and generate a **inspired** generic instantiation file.

The `outputAOTGenericReferenceFile` field in HybridCLRSettings.asset specifies the output file path, and the `maxGenericReferenceIteration` field specifies the maximum number of iterations for the generic recursive scan.

Since it is troublesome to convert the scanned generic types and functions into corresponding code references, all generated generic instantiation codes are **comment codes**, which are converted into correct instantiation references by developers themselves (**This operation is optional, it can not be processed at all or only part of it**), that is, instantiate the generic class or generic function in this comment in the AOT code. The method is roughly as follows:

```csharp

    // System.Collections.Generics.List`1<System.Object>.ctor
    new List<object>();

    // System.Byte[] Array.Empty`1<System.Byte>()
    Array.Empty<byte>();

```

Please add instantiation references to generic types and functions in other files, as this output file will be overwritten every time it is regenerated.

This generic instantiation documentation is only for inspiration, telling you which classes and functions can be instantiated with aot generics. After using the supplementary metadata mechanism,
**Do nothing** and do not affect normal operation. But if you manually instantiate aot generics, you can improve performance. The suggestion is to manually instantiate a small number of performance-sensitive classes or functions, such as `Dictionary<int,int>`.

For more specific AOT generic related documents, please see [AOT Generic Introduction](/hybridclr/aot_generic/).

#### ReversePInvokeWrapper

Generate a ReversePInvokeWrapper function for hot-updated C# static functions marked with `[MonoPInvokeCallback]` annotation. In this way, each hot update C# static function will have a unique corresponding C++ function,
It can be used to register in scripting languages such as lua and be called by scripting languages.

The `reversePInvokeWrapperCount` field in HybridCLRSettings.asset indicates the number of generated wrapper c++ functions. Please reserve enough to ensure that it exceeds the number of C# functions marked with `[MonoPInvokeCallback]` annotations in the hot update C# code. Otherwise an exception may be thrown.

For a more specific introduction to MonoPInvokeCallback, please see the document [MonoPInvokeCallback support] (/hybridclr/monopinvokecallback/)

#### Il2CppDef

Generate macro definitions related to the current Unity version. Similar to the following:

```cpp

// Il2CppCompatibleDefs.h

#define HYBRIDCLR_UNITY_VERSION 2020333
#define HYBRIDCLR_UNITY_2020 1
#define HYBRIDCLR_UNITY_2019_OR_NEW 1
#define HYBRIDCLR_UNITY_2020_OR_NEW 1
```

#### DHEAssemblyList

**Notice! Version 1.1.7 removed this field.**

Generate differential hybrid assembly list code.

Because HybridCLR needs to preprocess the differential mixed execution assembly at the stage of il2cpp initialization, it is currently provided to HybridCLR in the form of the generated assembly list code.

Examples are as follows:

```cpp
    // Il2CppCompatibleDefs.cpp file

	const char* g_differentialHybridAssemblies[]
	{

	//!!!{{DHE
        "Assembly-CSharp",
	//!!!}}DHE
		nullptr,
	};

```

#### DHEAssemblyOptionDatas

**Notice! Version 1.1.7 removed this field.**

Generate configuration data for differential hybrid assembly.

Loading a differential hybrid execution assembly requires some configuration data. For example, which functions are changed are calculated offline, so that there is no need to determine whether the function has changed at runtime. The configuration data is passed in as a parameter when calling `RuntimeApi::LoadDifferentialHybridAssembly`.

#### All

Execute the above four generation operations with one click.

## HybridCLR configuration

Click the menu `HybridCLR/Settings` to open the configuration interface. The fields are detailed below.

### enable

Whether to enable HyridCLR hot update. The default is true. If false, the package no longer includes HybridCLR functionality.

### useGlobalIl2cpp

Whether to use the global installation location, that is, the il2cpp directory under the editor installation location. The default is false. Generally, `useGlobalIl2cpp=true` is only required when packaging WebGL.

Note that even if `useGlobalIl2Cpp=true`, il2cpp will still be copied to the HybridCLRData directory during installation.
You need to manually replace the `{project}/HyridCLRData/LocalIl2CppData-{platform}/il2cpp/libil2cpp` directory with the corresponding directory under the editor installation directory. In addition, run `HybridCLR/Generate/*` to execute the generation operation. The output directory is still a local directory. You need to manually copy and replace the libil2cpp directory in the global installation location.

### hybridclrRepoURL

The address of the hybridclr warehouse, the default value is `https://gitee.com/focus-creative-games/hybridclr`.

### il2cppPlusRepoURL

The address of the il2cpp_plus warehouse, the default value is `https://gitee.com/focus-creative-games/il2cpp_plus`.

### hotUpdateAssemblyDefinitions

The list of hot update modules defined in the form of assembly definition (asmdef) is equivalent to `hotUpdateAssemblies` below, but it is more convenient to drag and drop asmdef modules in the editor, and it is not easy to make mistakes and write wrong names.

`hotUpdateAssemblyDefinitions` and `hotUpdateAssemblies` are combined to form the final hot update dll list. The same assembly should not appear in two lists at the same time, an error will be reported!

### hotUpdateAssemblies

Some assemblies exist in the form of dll, such as the hot update dll you created in an external project, or you directly use Assembly-CSharp as your hot update dll. Since there is no corresponding asmdef file, it can only be manually configured in the form of dll name.

Do not include the '.dll' suffix when filling in the assembly name, just like `Main`, `Assembly-CSharp`.

Assembly in asmdef form, you can also choose not to add it to `hotUpdateAssemblyDefinitions`, but add it to `hotUpdateAssemblies`. But this is not as convenient as directly dragging into the list, you can choose at your own discretion.

`hotUpdateAssemblyDefinitions` and `hotUpdateAssemblies` are combined to form the final hot update dll list. The same assembly should not appear in two lists at the same time, an error will be reported!

### preserveHotUpdateAssemblies

A list of reserved hot update dll names. Sometimes I want to add some hot update dlls in the future, and expect the scripts of these new hot update dlls to be mounted on resources. If you directly add the hot update dll name to hotUpdateAssemblies, an error that the assembly does not exist will be reported. The preserveHotUpdateAssemblies field is used to meet this requirement. These dlls are not checked for validity when packaging and will be added to an assembly list file like scriptingassemblies.json.

Do not include the '.dll' suffix when filling in the assembly name, just like `Abc`.

### hotUpdateDllCompileOutputRootDir

The output root directory of the compiled hot update dll. The final output directory is under the platform subdirectory of this directory, namely `${hotUpdateDllCompileOutputRootDir}/{platform}`.

### externalHotUpdateAssemblyDirs

Customize the search path for external hot update dlls. Some hot update projects of frameworks or projects are placed outside Unity, and the compiled dll is also outside. This parameter provides a hot update dll
The search path, so that there is no need to copy the external dll to the project or to the hotUpdateAssemblies directory every time.

- Search in the order of the search path, the higher the priority, the higher the priority.
- Search paths must be relative locations, relative to the project root. That is, fill in `mydir` and search for `{proj}/mydir`.
- For each path `dir`, it will first try to search `{dir}/{platform}`, and then try to search `{dir}`. This is done in order to take into account the specificity and versatility of the platform.

### strippedAOTDllOutputRootDir

Staging directory for trimmed AOT dlls. The final directory is under the platform subdirectory of this directory, namely `${strippedAOTDllOutputRootDir}/{platform}`.

### patchAOTA Assemblies

Supplementary metadata AOT dll list. The package itself does not use this configuration item. But it provides a place to configure the AOT dll list, which is convenient for developers to use in their own packaging process, so that developers do not need to define a separate AOT dll configuration script.

Do not include the '.dll' suffix when filling in the assembly name, just like `Main`, `Assembly-CSharp`.

### differentialHybridAssemblies

**Notice! Version 1.1.7 removed this field.**

A list of assemblies for differential mix execution. The assembly executed by differential hybrid and the assembly of pure hot update are not the same type of assembly, and cannot appear in the list of hotUpdateAssemblies at the same time.

### differentialHybridOptionOutputDir

**Notice! Version 1.1.7 removed this field.**

Runtime configuration parameters for assemblies executed by differential hybrids.

Some configuration parameters need to be passed to the assembly of differential mixed execution, such as which functions have changed. These configuration data are the optionBytes parameter of `LoadImageErrorCode RuntimeApi::LoadDifferentialHybridAssembly(byte[] dllBytes, byte[] optionBytes)`.

### outputLinkFile

When running the menu `HybridCLR/Generate/LinkXml` command, the output link.xml file path.

Do not point to `Assets/link.xml`, that link.xml is generally used to manually reserve the AOT type, and this automatically output link.xml will be overwritten every time.

### outputAOTGenericReferenceFile

The path of the AOT generic instantiation assembly file output when running the menu `HybridCLR/Generate/AOTGenericReference`.

### maxGenericReferenceIteration

When running the menu `HybridCLR/Generate/AOTGenericReference`, the generation tool recursively analyzes the number of iterations of AOT generic instantiation.

Because new generic classes and generic functions may be used indirectly in generic functions, multiple rounds of iterations are required to analyze all generic instantiations. The `maxGenericReferenceIteration` parameter is used to control the number of iterations. This parameter is generally within 10 enough, you can observe the log
It can be seen that the calculation terminates after several rounds of iterations. If there are still a large number of uncalculated iterations of generic types when the iteration terminates, this value can be increased appropriately.

Why not iterate until all generic instantiations are computed? Because there may be situations that can never be calculated. The following code, AOT.Show()
Due to recursive generic instantiation, it can never be calculated.

```csharp

    struct AOT<A>
    {

        public void Show()
        {
            var a = new AOT<AOT<A>>();
            a.Show();
        }
    }

```

### maxMethodBridgeGenericIteration

When running the menu `HybridCLR/Generate/MethodBridge`, the generation tool recursively analyzes the number of iterations of AOT generic instantiation. The meaning is similar to `maxGenericReferenceIteration`.

## Editor related tools

It mainly includes the following functions:

- Initialize HybridCLR
- Check and fix settings
- Automatically exclude hot update assembly when packaging
- Add the hot update dll name to the assembly list when packaging
- backup trimmed AOT dll
- Generate some files and codes needed for packaging
- Compile the hot update dll for the target platform

### Initialize HybridCLR

Run the `HybridCLR/Installer...` menu command to complete the initialization. See the menu command introduction above for details.

### Check and fix settings

It is part of the packaging workflow, and the relevant code is in `Editor/BuildProcessors/CheckSettings.cs`.

Contains the following actions:

- Set or clear the UNITY_IL2CPP_PATH environment variable according to whether HybridCLR is enabled. The UNITY_IL2CPP_PATH environment variable modified in the script is the environment variable of this process, so don't worry about interfering with other projects.
- Automatically turn off this option if it detects that incremental GC has been accidentally turned on.
- If no hot update assembly is set in HybridCLRSettings, an error will be displayed.


### Automatically exclude hot update assembly when packaging

It is part of the packaging workflow, and the relevant code is in `Editor/BuildProcessors/FilterHotFixAssemblies.cs`.

Obviously, the hot update assembly should not be processed by il2cpp and compiled into the final package body. We handle the `IFilterBuildAssemblies` callback,
Remove the hot update dll from the list of build assemblies.

The script will additionally check whether the name of the assembly is wrongly written, and whether there is a duplicate assembly configured by mistake.

### maxMethodBridgeGenericIteration

When running the menu `HybridCLR/Generate/MethodBridge`, the generation tool recursively analyzes the number of iterations of AOT generic instantiation. The meaning is similar to `maxGenericReferenceIteration`.

## Editor related tools

It mainly includes the following functions:

- Initialize HybridCLR
- Check and fix settings
- Automatically exclude hot update assembly when packaging
- Add the hot update dll name to the assembly list when packaging
- backup trimmed AOT dll
- Generate some files and codes needed for packaging
- Compile the hot update dll for the target platform

### Initialize HybridCLR

Run the `HybridCLR/Installer...` menu command to complete the initialization. See the menu command introduction above for details.

### Check and fix settings

It is part of the packaging workflow, and the relevant code is in `Editor/BuildProcessors/CheckSettings.cs`.

Contains the following actions:

- Set or clear the UNITY_IL2CPP_PATH environment variable according to whether HybridCLR is enabled. The UNITY_IL2CPP_PATH environment variable modified in the script is the environment variable of this process, so don't worry about interfering with other projects.
- Automatically turn off this option if it detects that incremental GC has been accidentally turned on.
- If no hot update assembly is set in HybridCLRSettings, an error will be displayed.


### Automatically exclude hot update assembly when packaging

It is part of the packaging workflow, and the relevant code is in `Editor/BuildProcessors/FilterHotFixAssemblies.cs`.

Obviously, the hot update assembly should not be processed by il2cpp and compiled into the final package body. We handle the `IFilterBuildAssemblies` callback,
Remove the hot update dll from the list of build assemblies.

The script will additionally check whether the name of the assembly is wrongly written, and whether there is a duplicate assembly configured by mistake.

### Generate some files and codes needed for packaging

Contains the following generation functions:

- Scan to generate link.xml
- generate bridge function
- Generate AOT generic instantiation code
- Generate ReversePInvokeCallback related wrapper files

These generation commands are included in the menu `HybridCLR/Generate/*`, please see the introduction document above.

## iOSBuild script

`Editor/Data~/iOSBuild` in the package contains the scripts needed to compile the iOS version libil2cpp.a. After running the `HybridCLR/Installer...` menu command to successfully initialize HybridCLR, it will be automatically copied to the `{project}/HybridCLRData/iOSBuild` directory. **Subsequent operations must be performed in the `{project}/HybridCLRData/iOSBuild` directory.**

For the specific operation of build libil2cpp.a, please refer to the document [iOS Platform Packaging](/hybridclr/build_ios_libil2cpp/).

## Runtime related scripts

Contains classes used at runtime. Currently relatively simple.

### LoadImageErrorCode

Error code of loading hot update dll.

### Metadata Mode HomologousImageMode

Two metadata schemas are currently supported:

#### `HomologousImageMode::Consistent` mode

That is, the supplementary dll is exactly the same as the trimmed dll when packaging. Therefore, the clipped dll generated during the build process must be used, and the original dll cannot be copied directly. We added processing code in `HybridCLR.BuildProcessors.CopyStrippedAOTAssemblies` to automatically copy these clipped dlls to the `{project}/HybridCLRData/AssembliesPostIl2CppStrip/{target}` directory when packaging.

#### `HomologousImageMode::SuperSet` mode

That is, the supplementary dll is a superset of the trimmed dll when packaging, and contains all the metadata of the trimmed dll. One of the easiest superset dlls to get is the original aot dll, which is also the recommended superset dll.

- The original UnityEngine-related AOT dll is in the PlayBackEngines subdirectory of the Unity installation directory
- The original .net core AOT dll such as mscorlib.dll is in the `unityaot{xxx}` directory of the Unity installation directory. 2019-2020 will be unified into the unityaot directory, and will be split into multiple directories starting from 2021. If you package android, take unityaot-linux, and if you package iOS, take unityaot-macos.
- The AOT dll of the plug-in is the original dll of the corresponding platform in the project directory. If it is in the form of source code, it is a compiled dll, just take the corresponding dll in the `HybridCLR/HotUpdateDlls/{platform}` directory

Take the Win64 target under Win of Unity 2020.3.33 version as an example:

- mscorlib.dll in `{editor}/Editor/Data/MonoBleedingEdge/lib/mono/unityaot`
- UnityEngine.CoreModule.dll in `{editor}/Editor/Data/Playbackengines/windowsstandalonesupport/Variations/il2cpp/Managed`
- protobuf-net.dll is the original `protobuf-net.dll` in your project
- The AOT dll corresponding to your AOT module Main is `HybridCLR/HotUpdateDlls/{platform}/Main.dll`

The `SuerSet` mode can also use the trimmed dll of the `Consistent` mode, since it obviously contains all the metadata for itself. However, the `SuperSet` mode is mainly to simplify the workflow and avoid the `metadata not match` problem that often occurs in the `Consistent` mode, so unless you want to optimize the memory, it is strongly recommended to use the original AOT dll.

### RuntimeApi

The underlying tool class for operating HybridCLR. There are a few more commonly used

- `LoadImageErrorCode LoadMetadataForAOTAssembly(byte[] dllBytes, HomologousImageMode mode)` is used to load supplementary metadata assembly.
- `LoadImageErrorCode UseDifferentialHybridAOTAssembly(string assemblyName)` When the differential hybrid execution assembly has not changed, you can choose to use the original AOT assembly completely. **Notice! Version 1.1.7 removed this function.**
- `LoadImageErrorCode LoadDifferentialHybridAssembly(byte[] dllBytes, byte[] optionBytes)` Load differential hybrid execution assembly. **Notice! Version 1.1.7 removed this function.**

### UnchangedAttribute

For differential mixed execution assembly, it is used to manually specify which functions are changed or not. The changed function is executed in interpreter mode, and the unchanged function is executed in native AOT mode.

Currently, for demonstration purposes, unchanged functions need to be manually marked, and later official versions will be automatically calculated, and this feature is basically not used.

### ReversePInvokeWrapperGenerationAttribute

Each function with the `[MonoPInvokeCallback]` attribute requires a unique corresponding wrapper function. These wrapper functions must be pre-generated during packaging and cannot be changed.
Therefore, if a function with the `[MonoPInvokeCallback]` feature is added in subsequent hot updates, there will be insufficient wrapper functions.

ReversePInvokeWrapperGenerationAttribute is used to reserve a specified number of wrapper functions for the current function added with the `[MonoPInvokeCallback]` attribute.

In the following example, 10 wrapper functions are reserved for functions signed by LuaFunction.

```csharp
    delegate int LuaFunction(IntPtr luaState);

    public class MonoPInvokeWrapperPreserves
    {
        [ReversePInvokeWrapperGeneration(10)]
        [MonoPInvokeCallback(typeof(LuaFunction))]
        public static int LuaCallback(IntPtr luaState)
        {
            return 0;
        }

        [MonoPInvokeCallback(typeof(Func<int, int, int>))]
        public static int Sum(int a, int b)
        {
            return a + b;
        }

        [MonoPInvokeCallback(typeof(Func<int, int, int>))]
        public static int Sum2(int a, int b)
        {
            return a + b;
        }

        [MonoPInvokeCallback(typeof(Func<int>))]
        public static int Sum3()
        {
            return 0;
        }
    }
```