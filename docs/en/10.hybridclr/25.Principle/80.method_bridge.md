---
title: AOT-interpreter bridge function
date: 2022-05-25 11:50:18
permalink: /hybridclr/method_bridge/
categories:
  - HybridCLR
  - performance
tags:
  - 
author: 
  name: walon
  link: https://github.com/pirunxi
---
# AOT-interpreter bridge function

Two-way function calls are required between the interpreter of the bridge function HybridCLR and AOT. For example, the interpreter calls the AOT function, or the AOT part has a callback function that calls the interpreter part.

The parameter passing and storage methods of the AOT part and the interpreter part are different. For example, the interpreter part calls the AOT function, and the parameters of the interpreter are all on the interpreter stack, and the function parameters of the interpreter must be passed to the AOT function by means of a suitable method. Similarly, the interpreter cannot directly obtain the parameters of the AOT callback function. Corresponding bridge functions must be generated for each type of signature function to realize the two-way function parameter transfer between the interpreter and the aot part.

Calling in the direction of `interpreter -> AOT` can be done through libraries like ffi, but the cost of function calls is too high. The most reasonable way is to generate this bidirectional bridge function in advance.

The internal calls of the interpreter go directly to the interpreter stack, no bridge function is needed.

According to the principle of the bridge function, for the fixed AOT part, the bridge function set is determined, and no new additional bridge function will be needed no matter any subsequent hot updates. **Therefore, there is no need to worry about the problem that the bridge function is missing suddenly after the hot update goes online.**

## Bridge function signature

The bridge function must be generated in the AOT part in advance, which is similar to the principle of lua's wrapper function.

In order to find the corresponding bridge function for each function called between `AOT <-> interpreter`, there must be a way to calculate the function signature. In addition, functions with completely equivalent parameter types and return value types can share the same bridge function, which greatly reduces the number of bridge functions. For the following example, for x64 and arm64 platforms, long and class types share the same signature. So they can all share a bridge function with `long (long, long)` signature.

```csharp
object Fun1(object a, long b);
long Fun2(long a, long b);
object Fun3(object a, object b);
```

There are some differences in how the ABIs of different operating systems and architectures handle function parameter passing and return values. Considering that both Android v8 and iOS are arm64, in order to maximize the performance of these two common platforms and balance the cost of maintaining too many platforms, we simply designed the most stringent signature calculation rules for 32 and 64 bits respectively, called Universal32 and Universal64, as well as the Arm64 family bridge signature calculation rules are designed for the mobile game arm 64-bit platform.

- Arm64
- Universal32 uses the abi intersection of all 32-bit platforms to calculate the signature
- Universal64 calculates the signature using the abi intersection method other than the arm64 platform

### Signature rules for Universal32

| type | signature|
|-|-|
|bool、byte| u1|
|sbyte |i1|
|short |i2|
|ushort、char| u2|
|int |i4|
|uint |u4|
|long |i8|
|ulong |u8|
|float |r4|
|double |r8|
|IntPtr |i4|
|UintPtr |u4|
|enum |The Universal32 signature corresponding to the underlying type|
|Value type reference and class type |i4|
|Value type |{S,C}{size}|

S and C correspond to the value types of aligment=1 and 8 respectively. For example, the signature of UnityEngine.Vector3 is S12.

### Sharing Rules for Universal64

| type | signature|
|-|-|
|bool、byte| u1|
|sbyte |i1|
|short |i2|
|ushort、char| u2|
|int |i4|
|uint |u4|
|long |i8|
|ulong |u8|
|float |r4|
|double |r8|
|IntPtr |i4|
|UintPtr |u4|
|enum |The Universal32 signature corresponding to the underlying type|
|value type|S{size)}|
|Vector2f|v2f|
|Vector3f|v3f|
|Vector4f|v4f|
|Vector2d|v2d|
|Vector3d|v3d|
|Vector4d|v4d|

Compared with Univeral32, the value type does not distinguish alignment, all use S.

### Sharing Rules for Arm64

| type | signature|
|-|-|
|bool、byte| u1|
|sbyte |i1|
|short |i2|
|ushort、char| u2|
|int |i4|
|uint |u4|
|long |i8|
|ulong |u8|
|float |r4|
|double |r8|
|IntPtr |i4|
|UintPtr |u4|
|enum |The Universal32 signature corresponding to the underlying type|
|Value type reference and class type |i8|
|Value type as parameter(size<=16) |S16|
|Value type as parameter(size>16) |sr|
|Value type as return value|S{size)}|
|Vector2f|v2f|
|Vector3f|v3f|
|Vector4f|v4f|
|Vector2d|v2d|
|Vector3d|v3d|
|Vector4d|v4d|


## HybridCLR default bridge function set

HybridCLR has scanned the Unity core library and common third-party libraries to generate a default bridge function set. The relevant code file is libil2cpp/hybridclr/interpreter/MethodBridge_{abi}.cpp, where {abi} is Arm64, Universal32 or Universal64.

## Custom bridge function set

In practical projects, there will always be some shared bridge functions of aot functions that are not in the default bridge function set. Therefore, tool scripts are provided in [hybridclr_unity package](/en/hybridclr/hybridclr_unity/), using the menu command `HybridCLR/Generate/MethodBridge` to automatically generate all bridge functions according to the assembly.

