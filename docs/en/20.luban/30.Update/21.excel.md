---
title: Data Definition—Excel
date: 2022-05-25 11:14:58
permalink: /luban/excel/
categories:
  - luban
tags:
  - 
author: 
  name: walon
  link: https://github.com/pirunxi
---
# Introduction to excel format

## Base

### Create a normal xlsx configuration table

- Assume that the configuration you want to create is an equipment list.
- Create equip.xlsx in the MyConfigs/Datas directory (in practice, it is recommended to create subdirectories by module, and create configurations in the module directory for easy maintenance and management), the content of which is as follows

|##var| id | name | attr | value|
| - | - | - | - | - |
| ##type |int|string|int| float |
|##group|c|s|c,s||
| | 1 | equip1 | 10|1.2|
| | 2 | equip2 | 15|3.4|

- Add a new row in MyConfigs/Datas/\_\_tables\_\_.xlsx. Some irrelevant columns are ignored.

|##var|full_name|value_type|define_from_excel|input|...|
|-|-|-|-|-|-|
||demo.TbItem|Item|true|equip.xlsx||

- At this point, the Add New Table tool is complete. Run check.bat to check whether it was successfully generated!

### introduction of excel header row

- The cell in the first column is `##var`, indicating that this line is a field definition line
- The cell in the first column is `##type`, indicating that this row is a type definition row
- The cell in the first column is `##group`, which means that this row is an export group row. **This line is optional**. In addition, leaving the cell blank means exporting for all groups.
- The cell in column 1 starts with ##** to indicate that this is a comment line. If there are multiple ## lines, the first line is used as the comment of the field in the code by default. You can explicitly specify it through ##comment A certain behavior code comment line.
- When filling in the multi-level field name line, use ##var to indicate that this is a secondary field line
- You can adjust the order of lines like ##xxx and ##yyy as you like, **but note** If the first line is a comment line, ##comment must be used instead of ##. Otherwise, the first line will be regarded as the field name line and an error will occur (this is for compatibility, the first line was forced to be the field name line in the early days, and only the beginning of ## is allowed)

<table  border="1">
<tr align="center">
  <td>##var</td>
  <td>id</td>
  <td>name</td>
  <td colspan="6">stages</td>
</tr>
<tr align="center">
  <td>##var</td>
  <td/>
  <td/>
  <td>id</td>
  <td>name</td>
  <td>desc</td>
  <td>location</td>
  <td>item_id</td>
  <td>num</td>
</tr>
<tr align="center">
  <td>##type</td>
  <td>int</td>
  <td>string</td>
  <td colspan="6">list,Stage</td>
</tr>
<tr align="center">
  <td>##</td>
  <td>id</td>
  <td>desc1</td>
  <td>desc1</td>
  <td>desc2</td>
  <td>desc3</td>
  <td>desc4</td>
  <td>desc5</td>
  <td>desc6</td>
</tr>
<tr align="center">
  <td>##comment</td>
  <td>id</td>
  <td>名字</td>
  <td>注释1</td>
  <td>desc2</td>
  <td>desc3</td>
  <td>desc4</td>
  <td>desc5</td>
  <td>desc6</td>
</tr>
<tr align="center">
<td/>
<td>1</td>
<td>task1</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>3</td><td>stage3</td><td>stage desc3</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
<tr align="center">
<td/><td>2</td>
<td>task2</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
</table>

### excel file read rules

- If no sheet is specified, all sheets will be read by default
- You can use sheet@xxx.xlsx to specify to read only this sheet data
- If the A1 cell data does not start with ##, it will be treated as a non-data sheet and ignored

### Supported excel file families

Support xls, xlsx, xlm, xlmx, csv. Basically, anything that can be opened by excel can be read.

### Support non-GKB and UTF-8 encoded csv files

Luban will intelligently guess its encoding and handle it correctly.

### Flexible configuration file organization

- You can put several tables into one xlsx, and each table occupies a sheet. You only need to specify this unit as the input of each table, such as input="xxx@item/test/abs.xlsx".
- A table can be split into several xlsx. Such as input="item/a.xlsx,bag/b.xlsx,c.xlsx".
- Can read all xlsx in a directory one by one. Such as input="bag" .

### Leave the cell blank to take the default value

Data other than beans can be left blank. Automatically take the default value. Note that the default value for non-nullable fields is the initial value, and the default value for nullable variables is null. For example, the default value of int is 0, but the default value of int? is null. The default value of string is an empty string of length 0, and the default value of string? is null.

## Data Format

### Limit column format and stream format

If a field limits the column range through a header or a multi-level header, its parsing format is the column-limited format.

If a field is only a certain subdata of a field with a limited column format, its parsing format is stream format.

Examples are as follows. Columns marked with @ are in restricted column format, and columns marked with ~ are in streaming format.

```xml
<bean name="Item">
   <var name="item_id" type="int"/>
   <var name="num" type="int"/>
   <var name="desc" type="string">
</bean>
```

<table border="1">
<tr align="center">
  <td>##var</td><td>id</td><td>name</td><td colspan="3">item</td> <td colspan="8">items</td>
</tr>
<tr align="center">
  <td>##type</td><td>int</td><td>string</td><td colspan="3">Item</td><td colspan="8">list,Item</td>
</tr>
<tr align="center">
  <td>##var</td><td/><td/><td>item_id</td><td>num</td><td>desc</td><td/><td/><td/><td/><td/><td/><td/><td/>
</tr>
<tr align="center">
  <td></td><td>@</td><td>@</td><td>@</td><td>@</td><td>@</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td><td>~</td>
</tr>
<tr>
  <td/><td>1</td><td>xxxx</td><td>1001</td><td>1</td><td>item 1</td><td>2001</td><td>1</td><td>item2</td><td/><td/><td/><td/>
</tr>
<tr>
  <td></td>
  <td>2</td>
  <td>xxxx</td>
  <td>1002</td>
  <td>3</td>
  <td>item 1</td>
  <td>2001</td>
  <td>1</td>
  <td>item2</td>
  <td>2002</td>
  <td>2</td>
  <td>item 2</td>
  <td></td>
  <td></td>
</tr>  
</table>

### Limit column format introduction

Through the header row and multi-level header row, you can precisely limit a certain data to certain column ranges.

For simple type data with only one atomic value, in the limited column format, since it is very clear that its value must come from a certain cell, it supports **default value** semantics, that is, if the cell is empty, the value takes The default value, for example, the default value of int type is 0, and the default value of int? is null.

In the restricted column format, the polymorphic bean type needs to use the $type column to specify the specific type name, and the nullable bean type also needs to use the $type column to indicate whether it is a valid bean or an empty bean.

If the type of the restricted column at the lowest level is container or bean, since the restricted column only limits the overall range of the data, but **does not limit** the scope of sub-data, the format for reading sub-data is **streaming format* *, that is, each sub-data is read in order.

A comprehensive example follows:

<table border="1">
<tr align="center"><td>##var</td><td>id</td><td colspan="4">shape</td><td colspan="4">item</td></tr>
<tr align="center"><td>##type</td><td>int</td><td colspan="4">Shape</td><td colspan="4">Item</td></tr>
<tr align="center"><td>##var</td><td></td><td>$type</td><td>radius</td><td>width</td><td>height</td><td>$type</td><td>item_id</td><td>num</td><td>desc</td></tr>
<tr align="center"><td/><td>1</td><td>Circle</td><td>10</td><td/><td/><td>Item</td><td>1001</td><td>1</td><td>item 1</td></tr>
<tr align="center"><td/><td>2</td><td>Rectangle</td><td></td><td>10</td><td>20</td><td>{}</td><td>1001</td><td>2</td><td>item 1</td></tr>
<tr align="center"><td/><td>3</td><td>圆</td><td>10</td><td/><td/><td>null</td><td></td><td></td><td></td></tr>
<tr align="center"><td/><td>4</td><td>Circle</td><td>10</td><td/><td/><td></td><td></td><td></td><td></td></tr>
</table>

Some data structures have special column qualification support.

#### `flags=1` enum type supports column-qualified mode.

Use the enumeration item as the column name, and the final value is the OR value of all non-zero or empty enumeration items.

<table border="1">
<tr align="center"><td>##var</td><td colspan="4">type</td> </tr>
<tr align="center"><td>##var</td><td>A</td><td>B</td><td>C</td><td>D</td></tr>
<tr align="center"><td/><td/><td>1</td><td>1</td><td></td></tr>
<tr align="center"><td/><td>1</td><td></td><td></td><td>1</td></tr>
</table>

#### Polymorphic beans support $type and $value respectively configured column-limited or stream-based mixed filling methods

That is, use the $type column as the limited type, use the $value column to limit the actual fields of the bean, and fill in all the fields of the bean in $value in a streaming manner.

<table border="1">
<tr align="center"><td>##var</td><td colspan="4">shape</td> </tr>
<tr align="center"><td>##var</td><td>$type</td><td colspan="3">$value</td></tr>
<tr align="center"><td/><td>Circle</td><td colspan="3">10</td></tr>
<tr align="center"><td/><td>Rectangle</td><td colspan="3">10,20</td></tr>
</table>

### Stream format introduction

For subdata that does not specifically limit the column range, use the streaming format (and this is the only way) to read the subdata sequentially.

Since the streaming format cannot distinguish between default cells and blank ignored cells, the **default value** semantics are not supported in the streaming format, and all blank cells will be ignored.
Furthermore, for the default value, a valid value must be filled in to represent the data, and it cannot be left blank to represent the data.

The default value filling rules in streaming format are as follows

- bool default value is false
- default value is 0 for int, float etc.
- The default value of string is ""
- Nullable variables, such as int? The empty value is null
- Container variables, need to have a closing curly brace '}' to indicate a null value (use '}' to indicate container termination)

As shown in the figure below, the item field is of the Item type and includes multiple sub-data, but no sub-column restrictions are added for its sub-fields, so it is parsed in a streaming format.

- For the column with id=1, all fields can be identified normally
- In the column with id=2, the second cell is empty and ignored, so trying to parse "item 1" as a num field throws a malformed exception.
- In the column with id=3, the third cell is empty and ignored. Although the desc field is a string value and can accept blank values, an exception of missing data will be thrown.

The correct way to record 2 and 3 is like 4 and 5.

<table border="1">
<tr align="center"> <td>##var</td><td>id</td><td>name</td><td colspan="3">item</td> </tr>
<tr align="center"><td>##type</td><td>int</td><td>string</td><td colspan="3">Item</td></tr>
<tr align="center"><td></td><td>@</td><td>@</td><td>~</td><td>~</td><td>~</td></tr>
<tr><td/><td>1</td><td>xxxx</td><td>1001</td><td>1</td><td>item 1</td> </tr>
<tr><td/><td>2</td><td>xxxx</td><td>1001</td><td></td><td>item 1</td> </tr>
<tr><td/><td>3</td><td>xxxx</td><td>1001</td><td>1</td><td></td> </tr>
<tr><td/><td>2</td><td>xxxx</td><td>1001</td><td>0</td><td>item 1</td> </tr>
<tr><td/><td>3</td><td>xxxx</td><td>1001</td><td>1</td><td>""</td></tr>
</table>

In streaming format, non-blank values must be filled in for each type, the rules are as follows

- bool false, true
- Valid integer values such as int, float
- string uses "" to represent a string of length 0, and uses other non-values to represent the value itself
- enum non-empty valid value
- The bean reads each field sequentially in a streaming format
- Polymorphic bean type First read in a string, which can be a specific subclass name or subclass name, and then read in each field of the type according to the subclass name.
- The nullable bean type reads a string first, if it is the type name of the bean or '{}', the stream format reads all the fields of the type; if it is null, it means empty, and the reading ends; in other cases, Throws an exception that fails parsing.
- array, list, set If the stream ends or the next read is '}', then the reading ends, otherwise, element_type is read in stream format, and so on.
- map If the stream ends or the next read is '}', the read ends, otherwise key_type and value_type are recursively read, and so on.

The following is an example of a streaming read of a very complex bean.

```xml
<bean name="Foo">
  <var name="x" type="int"/>
  <var name="y" type="int"/>
</bean>

<bean name="SubList">
  <var name="a" type="int"/>
  <var name="b" type="list,string"/>
  <var name="c" type="bool"/>
</bean>

<bean name="StreamDemo">
  <var name="x1" type="int"/>
  <var name="x2" type="Foo"/>
  <var name="x2_1" type="string"/>
  <var name="x2_2" type="list,int"/>
  <var name="x3_1" type="string"/>
  <var name="x4" type="list,Foo"/>
  <var name="x4_1" type="string"/>
  <var name="x5" type="SubList"/>
  <var name="x5_1" type="string"/>
  <var name="x7" type="list,SubList"/>
  <var name="x7_1" type="string"/>
  <var name="x8_0" type="map,int,int"/>
  <var name="x8" type="int">
</bean>
```
<div class="Excel">
<table border="1">
<tr align="center"><td>##var</td><td>id</td><td colspan="50">stream_demo</td> </tr>
<tr align="center"><td>##type</td><td>int</td><td colspan="50">StreamDemo</td></tr>
<tr align="center"><td>##</td><td/>
<td>x1</td>
<td colspan="2">x2</td>
<td>x2_1</td>
<td colspan="3">x2_2</td>
<td>x2_2 end flag</td>
<td>x3_1</td>
<td colspan="2">x4[0]</td>
<td colspan="2">x4[1]</td>
<td colspan="2">x4[2]</td>
<td>x4 end flag</td>
<td>x4_1</td>
<td>x5.a</td>
<td colspan="3">x5.b</td>
<td>x5.c</td>
<td>x5_1</td>
<td colspan="5">x7[0]</td>
<td colspan="5">x7[1]</td>
<td>x7 end flag</td>
<td>x7_1</td>
<td colspan="4">x8_0</td>
<td>x8_0 end flag</td>
<td>x8</td>
</tr>
<tr align="center"><td/>
<td>1</td>
<td>10</td>
<td>20</td><td>21</td>
<td>x2_1</td>
<td>2</td><td>3</td><td>4</td><td>}</td>
<td>x3_1</td>
<td>11</td><td>12</td><td>21</td><td>22</td><td>32</td><td>32</td><td>}</td>
<td>x4_1</td>
<td>100</td><td>aaa</td><td>bbbb</td><td>}</td><td>true</td>
<td>x5_1</td>
<td>100</td><td>aaa1</td><td>bbbb1</td><td>}</td><td>true</td>
<td>200</td><td>aaa2</td><td>bbbb2</td><td>}</td><td>false</td>
<td>}</td>
<td>x7_1</td>
<td>1</td><td>100</td><td>2</td><td>200</td><td>}</td>
<td>1234</td>
</tr>
</table>
</div>

### sep Introduction

In the streaming format, for composite data containing multiple data, sometimes it is desired to compactly fill in its multiple sub-data in one cell, and this can be achieved by using sep.

Since sep is very common and its usage is complex and diverse, it is introduced in a separate document [excel sep format introduction](/en/luban/sep/)

### Primitive data types

Supports bool, int, float, string, vector2, vector3, vector4 and other types, and their filling is consistent with conventional cognition.

|##var| x1 | x3 | x4 | x5 | x6  | x7   | s1    | v2    | v3   | v4     |
| -| -  |  -  | -  | -  | -   | -    | -     | -     | -    | -      |
|##type|bool|short|int|long|float|double|string       |vector2|vector3|vector4|
|##|desc1|id|desc4|desc5|desc6|desc7|desc1  |desc2|desc3|desc4|
|| false|  10| 100| 1000| 1.23| 1.2345|hello|1,2|1,2,3|1,2,3,4|
|| true |  20| 200| 1000| 1.23| 1.2345|world|1,2|1,2,3|1,2,3,4|

### text type

This type of data contains two fields, key and text, where the key can appear repeatedly, but the text is required to be exactly the same, otherwise an error will be reported. This is designed to prevent accidentally rewriting the key. **Note: The key is not allowed to be empty and the text is not empty**

If you want to fill in the blank localized string, you can leave the key and text completely blank, and the tool will treat it specially and will not add it to the key collection.

The key and text fields of text are both string types, so in the continuous data flow mode generated by continuous cells or sep, the rule of using "" to express blank strings must also be followed.

|##var|id|x|
|-|-|-|
|##type|int|text#sep=,|
|| 1| /demo/key1,aaaa|
||2|  /demo/key2,bbbb|
||3| | |

### datetime type

Time is a commonly used data type. Luban went out of his way to provide support.

- Fill in in plain character strings in the following 4 formats.
  - yyyy-mm-dd hh:mm:ss 如 1999-08-08 01:30:29
  - yyyy-mm-dd hh:mm 如 2000-08-07 07:40
  - yyyy-mm-dd hh 如 2001-09-05 07
  - yyyy-mm-dd 如 2003-04-05
- Fill in with the built-in time format of excel

|##var| id | x|
|-|-|-|
|##type|int| datetime|
|| 1|1999-09-09 01:02:03|
||2| 1999-09-09 01:02|
||3| 1999-09-09 01 |
||4| 1999-09-09|

### Nullable variables

Sometimes there is a variable, we want to fill in a valid value when its function is effective, and use a value to represent it when the function is not effective. For example, the int type often takes 0 or -1 as an invalid value constant. But sometimes, when 0 or -1 are also valid values, this doesn't work. In other words, sometimes 0 is used in the project group, and sometimes -1 is used as an invalid value mark, which is very inconsistent. We learn from sql and c#, introduce the concept of nullable value, and use null to express empty value.

|##var| id | x| color |
|-|-|-| - |
|##type|int| int?|QualityColor?|
|| 1| 1| A |
||2|  null|B|
||3| 2|null|

### Vector type vector2, vector3, vector4

vector3 has three fields float x, float y, float z, suitable for representing data such as coordinates.

|##var| id | x2|x3|x4|
|-|-|-| -| -|
|##type|int| vector2|vector3|vector4|
|| 1| 1,2|11,22,33|12,33,44,55|
||2|  2,3|22,44,55|6.5,4.7,8.9|

### Raw data list


<table border="1">
<tr align="center">
  <td>##var</td>
  <td>id</td>
  <td>arr1</td>
  <td colspan="4">arr2</td>
  <td>arr3</td>
  <td colspan="3">arr4</td>
</tr>
<tr align="center">
  <td>##type</td>
  <td>int</id>
  <td>(array#sep=;),int</td>
  <td colspan="4">list,int</td>
  <td>(list#sep=|),string</td>
  <td colspan="3">list,string</td>
</tr>
<tr align="center">
  <td>##</td>
  <td>id</id>
  <td>desc1</td>
  <td colspan="4">desc2</td>
  <td>desc3</td>
  <td colspan="3">desc4</td>
</tr>
<tr align="center">
<td/>
<td>1</td>
<td>1;2;3</td>
<td>1</td><td>2</td><td></td><td></td>
<td>xx|yy</td>
<td>xxx</td><td>zzz</td><td></td>
</tr>
<tr align="center">
<td/>
<td>2</td>
<td>2;4</td>
<td>3</td><td>4</td><td>5</td><td></td>
<td>aaaa|bbbb|cccc</td>
<td>aaa</td><td>bbb</td><td>ccc</td>
</tr>
<tr align="center">
<td/>
<td>3</td>
<td>2;4;6</td>
<td>3</td><td>4</td><td>5</td><td>6</td>
<td>aaaa|bbbb|cccc</td>
<td>aaa</td><td>bbb</td><td>ccc</td>
</tr>
</table>

### enumeration

Fill in the enumeration value in the form of enumeration name or alias or value.

defined in xml

```xml
<enum name="ItemQuality">
 <var name="WHITE" alias="白" value="0"/>
 <var name="GREEN" alias="绿" value="1"/>
 <var name="RED" alias="红" value="2"/>
</enum>
```

Or define in \_\_enums\_\_.xlsx

<table border="1">
<tr align="center"><td>##var</td><td>full_name</td><td>flags</td><td>unique</td><td>comment</td><td>tags</td><td colspan="5">*items</td></tr>
<tr align="center"><td>##var</td><td></td><td></td><td></td><td></td><td></td><td>name</td><td>alias</td><td>value</td><td>comment</td><td>tags</td></tr>
<tr align="center"><td/><td>ItemQuality</td><td>false</td><td>true</td><td/><td/><td>WHITE</td><td>白</td><td>0</td><td/><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>GREEN</td><td>绿</td><td>1</td><td/><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>RED</td><td>红</td><td>2</td><td/><td/></tr>
</table>

The data table is as follows.

|##var|id| quality| quality2 |
| -| - | - | - |
|##type|int|ItemQuality|ItemQuality|
| | 1| 白 | RED |
| | 2| GREEN | 红 |
| | 3| RED | WHITE |
| | 4| 1 | 0 |

### Nested Substructures

It is often encountered that a certain field is a structure, especially this structure will be reused in many configurations.

Suppose the task contains a RewardInfo field.

Defined in xml.

```xml
<bean name="Reward">
 <var name="item_id" type="int"/>
 <var name="count" type="int"/>
 <var name="desc" type="string">
</bean>
```

Or define in \_\_beans\_\_.xlsx

<table border="1">
<tr align="center"><td>##var</td><td>full_name</td><td >sep</td><td>comment</td><td colspan="5">fields</td>  </tr>
<tr align="center"><td>##var</td><td></td><td/><td/><td>name</td><td>type</td><td>group</td><td>comment</td><td>tags</td></tr>
<tr><td></td><td>Reward</td><td/><td/><td>item_id</td><td>int</td><td></td><td>道具id</td><td/></tr>
<tr><td></td><td></td><td/><td/><td>count</td><td>int</td><td></td><td>个数</td><td/></tr>
<tr><td></td><td></td><td/><td/><td>desc</td><td>string</td><td></td><td>描述</td><td/></tr>
</table>

The data table is as follows

<table border="1">
<tr align="center">
<td>##var</td>
<td>id</td>
<td colspan="3">reward</td>
</tr>
<tr align="center">
<td>##type</td>
<td>int</td>
<td colspan="3">Reward</td>
</tr>
<tr align="center">
<td>##</td>
<td>id</td>
<td>道具id</td><td>个数</td><td>描述</td>
</tr>
<tr align="center">
<td/>
<td>1</td>
<td>1001</td><td>1</td><td>desc1</td>
</tr>
<tr align="center">
<td/>
<td>2</td>
<td>1002</td><td>100</td><td>desc2</td>
</tr>
</table>

### List of simple structures

It is also common for a certain field to be a structural list. For example, the reward information list contains multiple reward information, and each reward has multiple fields.

Assume that the gift package contains a prop information list field. Supports 3 filling modes, and the specific choice is flexibly determined by the planner.

- All fields are fully expanded, and each cell is filled with one element. The disadvantage is that it takes up more columns. Such as the items1 field.
- Each structure occupies one cell, use sep to separate structure subfields. Such as the items2 field.
- The whole list occupies one cell, use sep to split the list and structure subfields. Such as the items3 field.

xml is defined as follows

```xml
<bean name="Reward">
 <var name="item_id" type="int"/>
 <var name="count" type="int"/>
 <var name="desc" type="string">
</bean>
```

Or it can also be defined in \_\_beans\_\_.xlsx, so I won’t go into details here. ==**The following examples involving structure definition are only examples of xml**==.

The data table is as follows:

<div class="Excel">
<table border="1">
<tr align="center">
<td>##var</td>
<td>id</td>
<td colspan="6">rewards1</td>
<td colspan="3">rewards2</td>
<td>rewards3</td>
</tr>
<tr align="center">
<td>##type</td>
<td>int</td>
<td colspan="6">list,Reward</td>
<td colspan="3">list,Reward#sep=,</td>
<td>(list#sep=|),Reward#sep=,</td>
</tr>
<tr align="center">
<td>##</td>
<td>id</td>
<td colspan="6">reward list desc1</td>
<td colspan="3">reward list desc2</td>
<td>reward list desc3</td>
</tr>
<tr align="center">
<td/>
<td>1</td>
<td>1001</td><td>1</td><td>desc1</td><td>1002</td><td>2</td><td>desc2</td>
<td>1001,1,desc1</td><td>1002,2,desc2</td><td>1003,3,desc3</td>
<td>1001,1,desc1|1002,2,desc2</td>
</tr>
<tr align="center">
<td/>
<td>2</td>
<td>1001</td><td>1</td><td>desc1</td><td></td><td></td><td></td>
<td>1001,1,desc1</td><td>1002,2,desc2</td><td></td>
<td>1001,1,desc1|1002,2,desc2|1003,1,desc3</td>
</tr>
</table>
</div>

Or you can qualify each element individually with a multi-level heading

<table border="1">
<tr align="center">
  <td>##var</td>
  <td>id</td>
  <td>name</td>
  <td colspan="9">rewards</td>
</tr>
<tr align="center">
  <td>##type</td>
  <td>int</td>
  <td>string</td>
  <td colspan="9">list,Reward</td>
</tr>
<tr align="center">
  <td>##var</td>
  <td></td>
  <td></td>
  <td colspan="3">0</td>
  <td colspan="3">1</td>
  <td colspan="3">2</td>
</tr>
<tr align="center">
  <td>##var</td>
  <td/>
  <td/>
  <td>item_id</td><td>num</td><td>desc</td>
  <td>item_id</td><td>num</td><td>desc</td>
  <td>item_id</td><td>num</td><td>desc</td>
</tr>
<tr align="center"><td/><td>1</td><td>task1</td><td>1</td><td>10</td><td>desc1</td><td>2</td><td>12</td><td>desc2</td><td>3</td><td>13</td><td>desc3</td></tr>
<tr align="center"><td/><td>2</td><td>task1</td><td>3</td><td>30</td><td>desc3</td><td>4</td><td>40</td><td>desc4</td><td/><td/><td/></tr>
<tr align="center"><td/><td>3</td><td>task1</td><td>5</td><td>50</td><td>desc5</td><td/><td/><td/><td/><td/><td/></tr>
</table>

### List of multi-line structures

Sometimes there are many fields in each structure of the list structure. If it is expanded horizontally, it will occupy too many columns, which is inconvenient to edit. If the table is dismantled, it will be inconvenient for both program and planning. At this time, you can use multi-line mode. Support any hierarchical multi-row structure list (that is, each element in the multi-row structure can also be multi-row), name#multi_rows=1 or *name can express a multi-row parsing field.

Assuming each task contains multiple stages, there is a stage list field.

```xml
<bean name="Stage">
 <var name="id" type="int"/>
 <var name="name" type="string"/>
 <var name="desc" type="string"/>
 <var name="location" type="vector3"/>
 <var name="reward_item_id" type="int"/>
 <var name="reward_item_count" type="int"/>
</bean>
```

<table border="1">
<tr align="center">
<td>##var</td>
<td>id</td>
<td>name</td>
<td colspan="6">*stage2</td>
</tr>
<tr align="center">
<td>##type</td>
<td>int</td>
<td>string</td>
<td colspan="6">list,Stage</td>
</tr>
<tr align="center">
<td>##</td>
<td>id</td>
<td>desc</td>
<td colspan="6">stage info</td>
</tr>
<tr align="center">
<td/>
<td>1</td>
<td>task1</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/>
<td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>3</td><td>stage3</td><td>stage desc3</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
<tr align="center">
<td/>
<td>2</td>
<td>task2</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
</table>

### list table (no primary key)

Sometimes just want to get a list of records, no primary key. mode="list" and index is empty, indicating no primary key table.

Definition table.

```xml
<table name="TbNotKeyList" value="NotKeyList" mode="list" input="not_key_list.xlsx"/>
```

Example data table.

|##var|x|y|z| num|
|-|-|-|-|-|
|##type|int|long|string|int|
||1|1|aaa|123|
||1|1|bbb|124|
||1|2|aaa|134|
||2|1|aaa|124|
||5|6|xxx|898|

### Multi-primary key table (joint index)

Multiple keys form a joint unique primary key. Use "+" to split the key, indicating a joint relationship.

Define the table.

```xml
<table name="TbUnionMultiKey" value="UnionMultiKey" index="key1+key2+key3" input="union_multi_key.xlsx"/>
```

Example data table.

|##var|key1|key2|key3| num|
|-|-|-|-|-|
|##type|int|long|string|int|
||1|1|aaa|123|
||1|1|bbb|124|
||1|2|aaa|134|
||2|1|aaa|124|
||5|6|xxx|898|

### Multi-primary key table (independent index)

Multiple keys, each independent and unique index. The difference from the joint index writing method is that "," is used to divide the key, indicating an independent relationship.
Define the table.

```xml
<table name="TbMultiKey" value="MultiKey" index="key1,key2,key3" input="multi_key.xlsx"/>
```

Example data table.

|##var|key1|key2|key3| num|
|-|-|-|-|-|
|##type|int|long|string|int|
||1|2|aaa|123|
||2|4|bbb|124|
||3|6|ccc|134|
||4|8|ddd|124|
||5|1|eee|898|

### Singleton table

Some configurations have only one copy globally, such as the opening level of the guild module, the initial size of the backpack, and the upper limit of the backpack. At this time, it is more appropriate to use a singleton table to configure these data.

|##var| guld_open_level | bag_init_capacity | bag_max_capacity | newbie_tasks |
| - |- | - | - | - |
| ##type | int | int | int | list,int|
| ## |desc1 | desc 2 | desc 3 | desc 4 |
| | 10 | 100| 500| 10001,10002 |

### Vertical Table

Most tables are horizontal tables, that is, one record per row. Some tables, such as singleton tables, are more comfortable to fill in vertically, with one field per line. A1 is ##column means using vertical table mode. The singleton table above is filled in as follows in vertical table mode.

<table border="1">
<tr align="center">
<td>##var#column</td>
<td>##type</td>
<td>##</td>
<td></td>
</tr>
<tr align="center">
<td>guild_open_level</td><td>int</td><td>desc1</td><td>10</td>
</tr>
<tr align="center">
<td>bag_init_capacity</td><td>int</td><td>desc2</td><td>100</td>
</tr>
<tr align="center">
<td>bag_max_capacity</td><td>int</td><td>desc3</td><td>500</td>
</tr>
<tr align="center">
<td>newbie_tasks</td><td>(list#sep=,),int</td><td>desc4</td><td>10001,10002</td>
</tr>
</table>

### Reference check

Foreign key data such as item ids are often filled in game configurations. These data must be legal id values. Luban supports checking the legality of ids when generating them. If there is an error, a warning will be issued. Not only the top-level fields of tables, but also the subfields of lists and nested structures support full reference checking.

```xml
<bean name="Reward">
 <var name="item_id" type="int" ref="item.TbItem"/>
 <var name="count" type="int"/>
 <var name="desc" type="string">
</bean>
```

<table border="1" >
<tr align="center">
  <td>##var</td>
  <td>id</td>
  <td >item_id</td>
  <td>items</td>
  <td colspan="3">reward</td>
  <td colspan="3">rewards</td>
</tr>
<tr align="center">
  <td>##type</td>
  <td>int</td>
  <td>int#ref=item.TbItem</td>
  <td>list,int#ref=item.TbItem</td>
  <td colspan="3">Reward</td>
  <td colspan="3">list,Reward#sep=,</td>
</tr>
<tr align="center">
  <td>##</td>
  <td>id</td>
  <td>desc1</td>
  <td>desc2</td>
  <td colspan="3">desc3</td>
  <td colspan="3">desc4</td>
</tr>
<tr align="center">
  <td/>
  <td>1</td>
  <td>1001</td>
  <td>1001,1002</td>
  <td>1001</td><td>10</td><td>item1</td>
  <td>1001,10,item1</td><td>1002,2,item2</td><td/>
</tr>
<tr align="center">
  <td/>
  <td>2</td>
  <td>1002</td>
  <td>1003,1004,1005</td>
  <td>1002</td><td>10</td><td>item2</td>
  <td>1004,10,item4</td><td>1005,2,item5</td><td>1010,1,item10</td>
</tr>
</table>

### Resource Checking

In the configuration, it is often necessary to fill in the resource path, such as the resource of the prop icon. These data are all of string type, and it is very easy to fill in mistakes, resulting in failure to display normally at runtime. luban supports the legality check of unity and ue4 resources and the general file path check. Not only the top-level fields of tables, but also the subfields of lists and nested structures support full reference checking.

For these fields add the attribute path=unity or path=ue or path=normal;xxxx.

|##var| id | icon |
| - | - | - |
| ##type| int | string#path=unity|
| ##|id | icon desc |
| | 1| Assets/UI/item1.jpg|
| | 2| Assets/UI/item2.jpg|

### Group export

Flexible group definition, not just client and server grouping. The following grouping granularities are supported:

- Table level grouping
- Field level grouping (arbitrary bean field granularity, not limited to top-level fields)

### Data label filtering

During the development period, some configurations are often made for development use only, such as test props, such as configurations used for automated testing. It is hoped that these data will not be exported during the official release.

|##var| id | name |  |
| - | - | - | - |
| ##type | int | string |  |
| ## | id | desc1| note |
| | 1 | item1 | export forever |
|##| 2 | item2 | never export |
|test| 4 | item4 | --export_exclude_tags test not exported |
|TEST| 5 | item5 | --export_exclude_tags test not exported |
|dev |6 | item6 | --export_exclude_tags dev not exported |
| | 7|item7| export forever |

### Multi-line record filling

Currently multiline is only supported for container type fields. Add * before the field name, such as *stages, or add multi_rows=1 parameter, such as stages#multi_rows=1.
Once the field is marked as multiple lines, each line will be read as an element of the field, such as list, bean type, each line will be read into a bean structure.

Multiple lines can be nested, that is, in a multi-line field, a field itself can also be a multi-line record. Examples can be found in [multi_rows_record](https://github.com/focus-creative-games/luban_examples/blob/main/DesignerConfigs/Datas/test/multi_rows_record.xlsx)

```xml
<bean name="Stage">
 <var name="id" type="int"/>
 <var name="name" type="string"/>
 <var name="desc" type="string"/>
 <var name="location" type="vector3"/>
 <var name="reward_item_id" type="int"/>
 <var name="reward_item_count" type="int"/>
</bean>
```

<table border="1">
<tr align="center">
<td>##var</td>
<td>id</td>
<td>name</td>
<td colspan="6">*stages</td>
</tr>
<tr align="center">
<td>##type</td>
<td>int</td>
<td>string</td>
<td colspan="6">list,Stage</td>
</tr>
<tr align="center">
<td>##</td>
<td>id</td>
<td>desc</td>
<td colspan="6">stage info</td>
</tr>
<tr align="center">
<td/>
<td>1</td>
<td>task1</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/>
<td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>3</td><td>stage3</td><td>stage desc3</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
<tr align="center">
<td/>
<td>2</td>
<td>task2</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
</table>

### Hierarchy title

In multi-line data or deeply nested data, if there are many data fields, it is difficult to distinguish sub-elements when filling in. Luban provides hierarchical titles to implement deep subfield correspondence. Take the above multi-line data list as an example, the first column is ##var to indicate that this is a subfield line.

- Subheadings for common bean structures

<table border="1">
<tr align="center">
  <td>##var</td>
  <td>id</td>
  <td>name</td>
  <td colspan="5">stage</td>
</tr>
<tr align="center">
  <td>##type</td>
  <td>int</td>
  <td>string</td>
  <td colspan="5">Stage</td>
</tr>
<tr align="center">
  <td>##var</td>
  <td/>
  <td/>
  <td>name</td>
  <td>desc</td>
  <td>location</td>
  <td>item_id</td>
  <td>num</td>
</tr>
<tr align="center">
  <td>##</td>
  <td>id</td>
  <td>name</td>
  <td>desc2</td>
  <td>desc3</td>
  <td>desc4</td>
  <td>desc5</td>
  <td>desc6</td>
</tr>
<tr align="center">
<td/>
<td>1</td><td>task1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/>
<td>2</td><td>task2</td><td>stage2</td><td>stage desc2</td><td>3,4,5</td><td>2001</td><td>3</td>
</tr>
</table>

- list, bean's multi-line expanded multi-level subtitle

<table border="1">
<tr align="center">
  <td>##var</td>
  <td>id</td>
  <td>name</td>
  <td colspan="6">*stages</td>
</tr>
<tr align="center">
  <td>##type</td>
  <td>int</td>
  <td>string</td>
  <td colspan="6">list,Stage</td>
</tr>
<tr align="center">
  <td>##var</td>
  <td/>
  <td/>
  <td>id</td>
  <td>name</td>
  <td>desc</td>
  <td>location</td>
  <td>item_id</td>
  <td>num</td>
</tr>
<tr align="center">
  <td>##</td>
  <td>id</td>
  <td>desc1</td>
  <td>desc1</td>
  <td>desc2</td>
  <td>desc3</td>
  <td>desc4</td>
  <td>desc5</td>
  <td>desc6</td>
</tr>
<tr align="center">
<td/>
<td>1</td>
<td>task1</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>3</td><td>stage3</td><td>stage desc3</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
<tr align="center">
<td/><td>2</td>
<td>task2</td>
<td>1</td><td>stage1</td><td>stage desc1</td><td>1,2,3</td><td>1001</td><td>1</td>
</tr>
<tr align="center">
<td/><td/><td/><td>2</td><td>stage2</td><td>stage desc2</td><td>1,2,3</td><td>1002</td><td>1</td>
</tr>
</table>

- list,bean's horizontal expansion of multi-level subheadings

<table border="1">
<tr align="center"><td>##var</td><td>id</td><td>name</td><td colspan="9">items</td></tr>
<tr align="center"><td>##type</td><td>int</td><td>string</td><td colspan="9">list,Item</td></tr>
<tr align="center">
  <td>##var</td>
  <td></td>
  <td></td>
  <td colspan="3">0</td>
  <td colspan="3">1</td>
  <td colspan="3">2</td>
</tr>
<tr align="center">
  <td>##var</td>
  <td/>
  <td/>
  <td>item_id</td><td>num</td><td>desc</td>
  <td>item_id</td><td>num</td><td>desc</td>
  <td>item_id</td><td>num</td><td>desc</td>
</tr>
<tr align="center"><td/><td>1</td><td>task1</td><td>1</td><td>10</td><td>desc1</td><td>2</td><td>12</td><td>desc2</td><td>3</td><td>13</td><td>desc3</td></tr>
<tr align="center"><td/><td>2</td><td>task1</td><td>3</td><td>30</td><td>desc3</td><td>4</td><td>40</td><td>desc4</td><td/><td/><td/></tr>
<tr align="center"><td/><td>3</td><td>task1</td><td>5</td><td>50</td><td>desc5</td><td/><td/><td/><td/><td/><td/></tr>
</table>

- map type's multi-level subheadings

<table border="1">
<tr align="center"><td>##var</td><td>id</td><td colspan="4">lans</td></tr>
<tr align="center"><td>##type</td><td>int</td><td colspan="4">map,string,string</td></tr>
<tr align="center"><td>##var</td><td/><td>ch-zn</td><td>en</td><td>jp</td><td>fr</td></tr>
<tr align="center"><td/><td>1</td><td>苹果</td><td>apple</td><td>aaa</td><td>aaa</td></tr>
<tr align="center"><td/><td>2</td><td>香蕉</td><td>banana</td><td>bbb</td><td>bbb</td></tr>
</table>

### Polymorphic structure

An example definition is as follows

```xml
<bean name="Shape">
 <bean name="Circle">
  <var name="radius" type="float"/>
 </bean>
 <bean name="Rectangle" alias="长方形">
  <var name="width" type="float"/>
  <var name="height" type="float"/>
 </bean>
 <bean name="Curve">
  <bean name="Line" alias="直线">
   <var name="param_a" type="float"/>
   <var name="param_b" type="float"/>
  </bean>
  <bean name="Parabola" alias="抛物线">
   <var name="param_a" type="float"/>
   <var name="param_b" type="float"/>
  </bean>
 </bean>
</bean>

```

<table border="1">
<tr align="center">
  <td>##var</td>
  <td>id</td>
  <td colspan="4">shapes</td>
</tr>
<tr align="center">
  <td>##type</td>
  <td>int</td>
  <td colspan="4">list,Shape#sep=,</td>
</tr>
<tr align="center">
  <td>##</td>
  <td>id</td>
  <td colspan="4"> shape desc</td>
</tr>
<tr align="center">
  <td/>
  <td>1</td>
  <td>Circle,10</td>
  <td>Rectangle,100,200</td>
  <td/>
  <td/>
</tr>
<tr align="center">
  <td/>
  <td>2</td>
  <td>Circle,20</td>
  <td>Rectangle,100,200</td>
  <td>Line,5,8</td>
  <td>Parabola,15,30</td>
</tr>
</table>

### field default value

We hope that when the cell in excel is left blank, the field will take the specified value instead of the default false, 0 or the like. Specify the default value by defining the default=xxx attribute of the field.

For example, for the record with id=2, both x1 and x2 are empty, x1=0, x2=-1.

|##var|id | x1 | x2#default=-1|
| - | - | - | - |
|##type| int | int | int |
|##|id|desc1|desc2|
||1 | 10 |20|
||2| | |
||3| | 30|

### Constant Aliases

There are often some commonly used values similar to enumerations in the game. For example, the id of the upgrade Dan needs to be filled in many places. If you directly use its item id, it is neither intuitive nor error-prone. Luban supports constant substitution. As an example, SHENG_JI_DAN will be replaced with 11220304 when exporting.

``` xml
<enum name="EFunctionItemId">
 <var name="SHENG_JI_DAN" alias="Upgrade Dan" value="11220304"/>
 <var name="JIN_JIE_DAN" alias="Advanced Dan" value="11220506"/>
</enum>
```

|##var|id| item_id |
|-| - | - |
|##type|int| int#convert=EFunctionItemId|
|##|id| desc|
||1 | SHENG_JI_DAN|
||2| Advanced Dan|
||3| 1001|

### The cell takes a non-zero default value

Only valid for excel format. Add xxx#default=value to the field name, and all blank cells will automatically take value. As shown in the figure below, the record with id=2, count=10, desc=haha. default is a unique attribute of excel format, it acts on the column and must be filled in **field name**.

|##var|id|count#default=10 |desc#default=haha|
|-|-|-| - |
|##type|int|int|string|
|| 1|1|abc|
||2|||
