---
title: Code and Data Generation
date: 2022-05-25 11:14:58
permalink: /luban/generate_code_data/
categories:
  - luban
tags:
  - 
author: 
  name: walon
  link: https://github.com/pirunxi
---
# Code and data generation

## Supported platforms, engines and languages

- Cross-platform
   - Win
   - Mac
   - Linux (including WSL)
- Support mainstream game development languages
   - c++ (11+)
   - c# (. net framework 4+. dotnet core 3+)
   - java (1.6+)
   - go (1.10+)
   - lua (5.1+)
   - js and typescript (3.0+)
   - python (3.0+)
   - erlang (18+)
   - rust (1.5+)
   - Other **protobuf** supported languages
- Support mainstream engines
   -unity
   - unreal
   - cocos2d-x
   - WeChat mini game platform
   - Other small game platforms that support js
- Support mainstream hot update solutions
   - xlua
   - tolua
   - slua
   - ILRuntime
   - sluaunreal
   - puerts
   - XIL
- Support mainstream open source frameworks
   - skynet
   - ET
   - GameFramework
   - xlua-framework

## Which data formats can be exported

- binary format. The format is compact and efficient to load, but basically unreadable. Recommended for official releases only.
- json format. Good readability. Elegant alignment format is supported, and compact format is also supported. Recommended for server-side, and for client-side development.
- **protobuf** format. Suitable for developers who are familiar with pb.
- **msgpack** format.
- lua format. Good readability. It is recommended only for the case where the client-side scripting language is lua.
- xml format.
- erlang format. For the erlang language only.
- yaml format.
- other formats. It is easy to extend support.

**In the same format, the data generated for different languages is exactly the same**.

The formats supported by different languages are as follows:

| language | binary | json | lua |
| :- | :-: | :-: | :-:|
| c# | :heavy_check_mark: | :heavy_check_mark: |
|java| :heavy_check_mark: | :heavy_check_mark: |
|go | :heavy_check_mark: | :heavy_check_mark: |
|c++| :heavy_check_mark: | :x: |
|go|:heavy_check_mark: | :heavy_check_mark: |
|python| :heavy_check_mark: | :x: |
|typescript| :heavy_check_mark: | :heavy_check_mark: |
|rust| :x: | :heavy_check_mark: | 
|lua| :heavy_check_mark: | :x: | :heavy_check_mark: |
|erlang| erlang |
|protobuf|all|

## Detailed documentation for the luban command line tool?

See [luban command line](/en/luban/command_tools/)

## How to generate code and data

See the link above for detailed documentation. There are three tools related to code generation, all in the luban_examples/Tools directory.

- Luban.Client. Luban tool client
- Luban. Server. Luban tool server side
- Luban.ClientServer. The front and back ends of Luban tools are integrated.

For the sake of simplicity for novices, we introduce the usage of Luban.ClientServer, the command is as follows:

```shell
dotnet %LUBAN_CLIENT_SERVER_DLL% -j cfg -- ^
 -d %ROOT_FILE% ^
 --input_data_dir %INPUT_DATA_DIR% ^
 --output_code_dir %OUTPUT_CODE_DIR%
 --output_data_dir %OUTPUT_DIR% ^
 --gen_types %GEN_TYPE% ^
 -s %GROUP%
```

in:

- LUBAN_CLIENT_SERVER_DLL is the path of Luban.ClientServer.dll, which can point to luban_examples/Tools/Luban.ClientServer/Luban.ClientServer.dll
- ROOT_FILE is the root definition file, pointing to MyConfigs/Define/\_\_root\_\_.xml
- INPUT_DATA_DIR is the root directory of configuration data, pointing to MyConfigs/Datas
- OUTPUT_CODE_DIR is the directory where the code is generated
- GEN_TYPE is the generation type. If you use unity and want to generate c# code and export json data, use "code_cs_unity_json,data_json"
- GROUP for export grouping. The client takes client, the server takes server, and all take all

For more project types, see [Example Projects](https://github.com/focus-creative-games/luban_examples/tree/main/Projects)

## Generate c# code for unity project and export json data

See above for an introduction to the command line. Your build command is roughly as follows

```shell
dotnet %LUBAN_CLIENT_SERVER_DLL% -j cfg -- ^
 -d %ROOT_FILE% ^
 --input_data_dir %INPUT_DATA_DIR% ^
 --output_code_dir %OUTPUT_CODE_DIR%
 --output_data_dir %OUTPUT_DIR% ^
 --gen_types "code_cs_unity_json,data_json" ^
 -s client
```

That is, the --gen_types parameter takes "code_cs_unity_json,data_json", and the -s parameter takes client

For specific projects, see [Csharp_Unity_Json](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Csharp_Unity_json)

For more project types, see [Example Projects](https://github.com/focus-creative-games/luban_examples/tree/main/Projects)

## Generate ts code for unity + puerts project and generate json data

--gen_types parameter takes "code_typescript_json,data_json", -s parameter takes client

For specific projects, see [Typescript_Unity_Puerts_Json](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/TypeScript_Unity_Puerts_Json)

## Generate c++ code (not blueprint) and binary data for UE4 project

The reference project for the benchmark is [Cpp_Unreal_bin](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Cpp_Unreal_bin).


Since the generated code depends on some header files, you need to copy Source\Cpp_Unreal\Private\bright from this project to a suitable location for your project. You must ensure that the bright directory is within the include directory path, such as #include "bright/serialization/ByteBuf.h" in the generated code to find this file.

Then the command line parameter takes --gen_types "code_cpp_bin,data_bin"

## Other types of project types, how to generate code and data
  
Between different projects, only --gen_types are different, please find the project that matches your project from [Example Project](https://github.com/focus-creative-games/luban_examples/tree/main/Projects) , refer to gen_code.bat in the corresponding directory.

## Generate protobuf definition file and protobuf data format

Currently supports proto2 and proto3 syntax

### protobuf2

Only export in bin format is supported.

Take --gen_types code_protobuf2,data_protobuf_bin, see [Protobuf2_bin](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Protobuf2_bin). Each exported data file corresponds to the serialized content of the Table class, just load it. Take the item.TbItem table as an example.

```csharp
var tbItem = ItemTbItem.Parser.ParseFrom(File.OpenRead("pb_datas/item_tbitem.bytes"));

```

### protobuf3

Both bin format and json format export are supported.

- Export in binary format. --gen_types code_protobuf3, data_protobuf_bin
- Export in json format. --gen_types code_protobuf3, data_protobuf_json

## Generate msgpack data

Just take --gen_types data_msgpack. See [MsgPack_bin](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/MsgPack_bin)

## Generate flatbuffers definition file and flatbuffers data format

Take --gen_types code_flatbuffers,data_flatbuffers_json, see [Flatbuffers_json](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Flatbuffers_json).

Due to the complexity of the binary format, only the json format is supported now, but users can use the flatc tool to convert the data into binary! specially generated convert_json_2_binary.bat
The two batch files, convert_json_2_binary.sh and convert_json_2_binary.sh, are convenient for automatic one-click conversion.

At present, because flat_buffers does not support the element type of the container as union, there are some compatibility issues, but it can be solved in a roundabout way by using a bean to contain this union field in the project.

There are some differences in the output format of data_flatbuffers_json and data_json

- The top level of data_flatbuffers_json is a table containing the data_list field, and the top level of data_json directly corresponds to the content of data_list
- flatbuffers do not support localization. So its text type export format is string, and data_json is {"key":"xxx", "text":"text}
- When data_flatbuffers_json serializes bean type fields, if a polymorphic type is encountered, it will serialize an additional xxx_type field of string type to indicate the type of union. This is exactly the case data_flatbuffers_json does not support union in the container
- If the data output by data_flatbuffers_json contains container type data and the element type is union, it cannot be parsed correctly.

## Only generate code or data?

Take [Csharp_Unity_Json](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Csharp_Unity_json) as an example.

- --gen_types code_cs_unity_json only generate code
- --gen_types data_json only generate data

## Some string fields in the configuration are resource addresses, and these resource addresses are exported uniformly

When defining the type first, add a tag like '#res=xxx', where xxx can take any value. As follows.

```xml
  <bean name="TestRes">
    <var name="icon" type="string#res=item"/>
  </bean>
```

Take '--gen_types data_resources', and add the parameter '--output:data:resource_list_file resources.txt'. Run to export all the data with res tag to the resources.text file.

Assuming that the configuration table contains the two data of icon="/ui/icon1.jpg" and icon="/ui/icon1/jpg", the content of the exported resource list is

```txt
item,/ui/icon1.jpg
item,/ui/icon2.jpg
```

See example [GenerateDatas](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/GenerateDatas)/gen_resource_list.bat file.

## In the generated c# code, the type of vector is changed from System.Numerics.Vector{2,3,4} to UnityEngine.Vector{2,3,4}

Add the --cs:use_unity_vector option to the command line parameters. See example [Csharp_Unity_bin](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Csharp_Unity_bin)

## Custom code naming style

Can. Add the option --naming_convention_bean_member none to do it. Make the field names in the generated code the same as the definition names.

The following code naming styles are supported:

- none. No naming style, the generated field name is the same as the defined name
- language_recommend. That is, according to the generated language, the style recommended by the language is automatically set. For example, c# is PascalCase, java is camelCase, and python is under_scores.
- camel Calse. That is, in camel case, a field name in the style of xxxYyyy is generated.
- PascalCase. That is, in Pascal form. Generate field names in the style of XxxYyy.
- under_scores. underlined form. That is, a field name in the style of xxx_yyy is generated.

By default language_recommend is used.

## What is the difference between code_cs_json and code_cs_unity_json in gen_types

Code_cs_json uses the System.Text.Json library in the generated code, which is only available in versions after .net core 3, and the current .net version of unity does not support it, so this is for server projects based on .net coer.
code_cs_unity_json uses the third-party SimpleJson library, which is compatible with the .net version of unity. When generating c# code for loading json data for unity, you can (currently only have this option) choose this.

## The meaning of -j cfg in the command line parameters

The long option corresponding to the -j option is named --job, indicating the generation type. Since luban currently supports three types of generation tasks: message (proto), database (db), and configuration (cfg), the functions of these generation tasks are completely different, and the parameters
The difference is quite large, you need to use -j to distinguish different generation tasks.

## The top-level namespace of the generated configuration code is cfg, can this namespace be omitted or use other values?

Yes. The value corresponding to the topmodule configuration item in \_\_root\_\_.xml is the top-level namespace, which can be adjusted to be empty or other values.

## The suffix of the generated data file

The default file suffix of the data format is as follows

|data|extension|
|-|-|
|data_bin|bin|
|data_json|json|
|data_json2|json|
|data_lua|lua|
|data_xml|xml|
|data_yaml|yml|
|data_protobuf|bp|

The suffix of the output file can be manually specified by the command line option "--data_file_extension xxx".

## enum, bean type code export rules

Not all defined types generate code and must satisfy one of the following rules:

- the type directly or indirectly referenced by the exported table
- The type specified by the ref item of service in root.xml. As shown in the figure below, even if no table directly or indirectly refers to the test.DemoEnum and test.DemoBean types, they will generate code when the server target.

```xml
<service name="server" managers="Tables" group="s">
   <ref name="test.DemoEnum"/>
   <ref name="test.DemoBean"/>
</service>
```

## Different export formats Performance test results

hardware:

  Intel(R) Core i7-10700 @ 2.9G 16 cores

  32G memory

data set
  
   500 excel sheets
   Each table has 1000 rows of relatively large records
   Each table file size 132k

Test Results:

| Format | First Elapsed Time | Cumulative Elapsed Time | Individual Output File Size | Total Output File Size |
| ---- | --------| ------  | ----            | ------ |
| bin  | 15.652 s| 797 ms  | 164 K            | 59.5 M |
| json | 17.746 s| 796 ms  | 1.11 M           | 555 M   |
| lua  | 17.323 s| 739 ms  | 433 K           | 212 M   |

## Binary and json format loading performance comparison?

Take the DesignerConfigs configuration of luban_examples as the test data, and use the csharp_Unity_bin and csharp_Unity_json projects under Projects as the test comparison,
Load cfg.Table 100 times.

The binary format takes 28ms, and the json format takes 112ms.

Load performance is about 4:1.
