---
title: Localization
date: 2022-05-25 11:14:58
permalink: /pages/b53da1/
categories:
  - luban
tags:
  - 
author: 
  name: walon
  link: https://github.com/pirunxi
---
# localization

Multiple localization mechanisms are supported to deal with different occasions respectively, and they can be used at the same time.

## Static text value localization

For text values that need to be localized, the localization conversion has been completed when the configuration is exported, which is suitable for different packages or different configurations in different regions. Static text value localization is achieved through the following aspects:

- Use the text type to identify strings that need to be localized. The text type consists of two fields, key and value.
- Use the localization mapping table to provide mappings from text to other languages
- The text that has not been localized is output to a file separately, so that it is convenient to know which text values have not completed the localization mapping

### Example table that needs localization

<table border="1">
<tr align="center">
   <td>##var</td>
   <td>id</td>
   <td colspan="2">name</td>
   <td>desc</td>
   <td>count</td>
</tr>
<tr align="center">
   <td>##type</td>
   <td>int</td>
   <td colspan="2">text</td>
   <td>string</td>
   <td>int</td>
</tr>
<tr align="center">
   <td/>
   <td>1</td>
   <td>/demo/key1</td><td>Apple</td>
   <td>This is an apple</td>
   <td>100</td>
</tr>
<tr align="center">
   <td/>
   <td>2</td>
   <td>/demo/key2</td><td>banana</td>
   <td>This is a banana</td>
   <td>100</td>
</tr>
<tr align="center">
   <td/>
   <td>3</td>
   <td>/demo/key3</td><td>Watermelon</td>
   <td>This is a watermelon</td>
   <td>100</td>
</tr>
</table>

### Text value mapping file

|##var| key | origin_text | text_tw | text_en |
| - | - | - | - | - |
|##type|string|string|string|string|
|##|Localization key| Original value | Traditional value | English |
||/demo/key1|apple|apple|apple|
||/demo/key2|banana|banana|banana|

## Luban.Client commands

There are three parameters related to static text value localization

- l10n:input_text_files localization mapping files
- l10n:text_field_name The target field name of the mapping. Because it is possible that multiple languages are in the same mapping table (such as text_tw and text_en)
- l10n:output_not_translated_text_file The text of the text value localization mapping has not been completed

The following is an example script

```shell
%GEN_CLIENT% -h %LUBAN_SERVER_IP% -j cfg --^
 -d %DEFINE_FILE%^
 --input_data_dir %CONF_ROOT%\Datas ^
 --output_code_dir Gen ^
 --output_data_dir config_data ^
 --gen_types data_json ^
 -s all  ^
--l10n:input_text_files l10n/cn/TextTable_CN.xlsx ^
--l10n:text_field_name text_en ^
--l10n:output_not_translated_text_file NotLocalized_CN.txt
```

## Example output

The content of the exported json file is

```json
[
   {
     "id": 1,
     "text": {
       "key": "/demo/key1",
       "text": "apple"
     },
     "desc": "This is an apple",
     "count": 100
   },
   {
     "id": 2,
     "text": {
       "key": "/demo/key2",
       "text": "banana"
     },
     "desc": "This is a banana",
     "count": 100
   },
   {
     "id": 3,
     "text": {
       "key": "/demo/key3",
       "text": "Watermelon"
     },
     "desc": "This is a watermelon",
     "count": 100
   }
]
```

In the example /demo/key3 is not provided in the localization mapping table because output_l10n_not_translated_text_file specifies the list of unmapped localized text values.

```text
/demo/key3|This is a watermelon
```

## Dynamic localization of text values

Dynamically switch the text type field to the target language at runtime, and the program does not need to query in the localization mapping table according to the id, which simplifies the use. Note that currently only the text type field in the bean is supported, such as list and text are not yet supported. Dynamic localization of text values is supported through:

- Identifies the field as text type
- Provide localization mapping function of (string key, string origin_value) => (string target_value)
- Call the cfg.Tables.TranslateText function at runtime to switch all text type values in the configuration to the target language with one click
- A string {field}_l10n_text field is additionally generated for the text type field. You can take this field to the localization mapping table to query its text value in other languages at runtime

The implementation of the localization mapping function is relatively simple, the core is how to make the text value localization mapping configuration? Users can either use a custom localization mapping table, or use a common luban configuration table to provide text value mapping configuration, as shown in the following figure:

|##var| key | origin_text | text_tw | text_en |
|-|-|-|-|-|-|
|##type| string| string| string| string|
|##|Localization key| Original value | Traditional value | English |
||/demo/key1|apple|apple|apple|
||/demo/key2|banana|banana|banana|

Switching to different target languages is achieved by providing different mapping functions, for example

```csharp
/// for switching to en
string TextMapper_en(string key, string originText) 
{
    return tables.TbTextMapper.GetOrDefault(key)?.TextEn ?? originText;
}

/// for switching to tw
string TextMapper_tw(string key, string originText) 
{
    return tables.TbTextMapper.GetOrDefault(key)?.TextTw ?? originText;
}

void SwitchLanguages(cfg.Tables tables)
{
  // Switch all text fields to en
   tables.TranslateText(TextMapper_en);

  // Switch all text fields to tw
   tables.TranslateText(TextMapper_tw);

  // When the current language is tw, switch is not used,
  // Get the English text corresponding to the desc field of prop 1001
  var desc_en = table.TbTextMapper.Get(tables.TbItem.Get(1001).Desc_l10n_key).TextEn;
}
```

## multi-branch data

Luban supports the data mode of main+patches. On the basis of the main version data, a patch data is provided, and the final target data is generated after merging and processing.

Take the gen_apply_patch_CN.bat script in the luban_examples/Projects/L10N directory as an example, the command line is as follows.

     %GEN_CLIENT% -h %LUBAN_SERVER_IP% -j cfg --^
     -d %CONF_ROOT%\Defines\__root__.xml ^
     --input_data_dir %CONF_ROOT%\Datas ^
     --output_code_dir Gen ^
     --output_data_dir config_data ^
     --gen_types data_lua ^
     -s all  ^
     --l10n:patch cn ^
     --l10n:patch_input_data_dir l10n/cn

Indicates that the patch name to be generated is cn, the root directory of the branch data is l10n/cn, and there are two xlsx files in the directory: Patch_CN_1.xlsx and Patch_CN_2.xlsx, and merge the data in these two files into DesignerConfigs/Datas/ l10n directory Patch.xlsx file, and generate lua format data.

Patch.xlsx content is

<table border="1">
<tr align="center">
  <td>##</td>
  <td>id</td>
  <td>value</td>
</tr>
<tr align="center">
  <td>##</td>
  <td/>
  <td/>
</tr>
<tr align="center">
  <td/>
  <td>11</td>
  <td>1</td>
</tr>
<tr align="center">
  <td/>
  <td>12</td>
  <td>2</td>
</tr>
<tr align="center">
  <td/>
  <td>13</td>
  <td>2</td>
</tr>
<tr align="center">
  <td/>
  <td>14</td>
  <td>4</td>
</tr>
<tr align="center">
  <td/>
  <td>15</td>
  <td>5</td>
</tr>
<tr align="center">
  <td/>
  <td>16</td>
  <td>6</td>
</tr>
<tr align="center">
  <td/>
  <td>17</td>
  <td>7</td>
</tr>
<tr align="center">
  <td/>
  <td>18</td>
  <td>8</td>
</tr>
</table>

The content of Patch_CN_1.xlsx is

<table border="1">
<tr align="center">
   <td>##</td>
   <td>id</td>
   <td>value</td>
   <td/>
</tr>
<tr align="center">
   <td>##</td>
   <td/>
   <td/>
   <td>Comments</td>
</tr>
<tr align="center">
   <td/>
   <td>11</td>
   <td>1001</td>
   <td>Overwrite the original value 1</td>
</tr>
<tr align="center">
   <td/>
   <td>12</td>
   <td>1002</td>
   <td>Overwrite the original value 2</td>
</tr>
<tr align="center">
   <td/>
   <td>20</td>
   <td>20</td>
   <td>Add 20</td>
</tr>
<tr align="center">
   <td/>
   <td>21</td>
   <td>21</td>
   <td>Add 21</td>
</tr>
</table>

The content of Patch_CN_2.xlsx is

<table border="1">
<tr align="center">
   <td>##</td>
   <td>id</td>
   <td>value</td>
   <td/>
</tr>
<tr align="center">
   <td>##</td>
   <td/>
   <td/>
   <td>Comments</td>
</tr>
<tr align="center">
   <td/>
   <td>30</td>
   <td>300</td>
   <td>Add 30</td>
</tr>
<tr align="center">
   <td/>
   <td>31</td>
   <td>310</td>
   <td>Add 31</td>
</tr>
</table>

The generated lua format data is

    return
    {
    [11] = {id=11,value=1001,},
    [12] = {id=12,value=1002,},
    [13] = {id=13,value=3,},
    [14] = {id=14,value=4,},
    [15] = {id=15,value=5,},
    [16] = {id=16,value=6,},
    [17] = {id=17,value=7,},
    [18] = {id=18,value=8,},
    [20] = {id=20,value=20,},
    [21] = {id=21,value=21,},
    [30] = {id=30,value=300,},
    [31] = {id=31,value=310,},
    }

So far, the data merging is completed. The patch function is suitable for minor data changes, and is suitable for making overseas multi-regional configurations with different detailed configurations. There is no need to copy the main version data, and then modify the final data on it, which greatly optimizes the localization of production. Configured workflow.

## Time localization

After specifying the localized time zone, the datetime type data will generate the UTC time at the corresponding moment according to the target time zone, which is convenient for the program to use.

Specify the time zone through the parameters of Luban.Client:

   -t, --l10n_timezone {timezone}

The time zone is the time zone name under linux or win, for example: -t "Asia/Shanghai" or -t "China Standard Time" specifies that the target time zone is Asia Shanghai (that is, Beijing time)
