---
title: HybridCLR source code structure and debugging
date: 2022-05-25 11:50:18
permalink: /hybridclr/source_inspect/
categories:
  - HybridCLR
tags:
  - 
author: 
  name: Code Philosophy
  link: https:://code-philosophy.com
---

# HybridCLR source code structure and debugging

## HybridCLR Module Introduction

HybridCLR is an extension based on the unity il2cpp runtime. In order to extend il2cpp from AOT to AOT+interpreter hybrid mode, HybridCLR implements the following functions:

- Dll parsing library implemented by c++
- Metadata registration. Since il2cpp is a static AOT, the original code does not support dynamic registration, because a small amount of modification (hundreds of lines)
- Instruction set conversion. Convert raw IL instructions into more efficient register instructions
- Register interpreter. Implemented an efficient interpreter.

In terms of directory structure, it corresponds to:

- HybridCLR's own source code
   - interpreter module
   - metadata metadata parsing and registration module
   - transform instruction set conversion module

- Modifications to il2cpp source code

     HybridCLR mainly modifies the il2cpp source code to support dynamic registration of metadata. In most places, only hook processing is inserted, and the original implementation is not modified. E.g:

```cpp
const char* il2cpp::vm::GlobalMetadata::GetStringFromIndex(StringIndex index)
{
    // ==={{ HybridCLR
    if (HybridCLR::metadata::IsInterpreterIndex(index))
    {
        return HybridCLR::metadata::MetadataModule::GetStringFromEncodeIndex(index);
    }
    // ===}} HybridCLR

    IL2CPP_ASSERT(index <= s_GlobalMetadataHeader->stringCount);
    const char* strings = ((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->stringOffset) + index;
    return strings;
}
```

### Transform Implementation Introduction

Very similar to regular instruction tree analysis. divided into parts

- BasicBlock division. Divide the original IL instruction into multiple BasicBlocks, each BasicBlock does not contain any jump function. Doing so can be more efficient to avoid accidental merging of instructions across jump blocks
- Simulate the execution of all logical branches, including jumps and exception branches, and convert each IL instruction into a corresponding register instruction.
- Instruction optimization (to be done). Development is expected to begin next month. At that time, most instructions can get 100-300% performance improvement.

### Interpreter Implementation Introduction

relatively straightforward. It is to interpret and execute instructions.

## debug

The core work of the HybridCLR interpreter consists of two parts:

- Instruction set conversion. Convert stack-based IL instructions to register-based versions. HiTransform::Transform function in HybridCLR/transform/transform.cpp.
- Interpreted execution of register instructions. Interpreter::Execute function in HybridCLR/interpreter/interpreter_Execute.cpp.

As long as the breakpoints are to these two functions, it is easy to follow the entire process from the conversion of the IL function to the solution execution step by step.

### PC, MAC create debugging project

- Prepare Unity 2020.3.33 version. According to your platform, the corresponding il2cpp module must be installed at the same time.
- Project Settings settings
   - Scripting Backend for IL2Cpp
   - C++ Compiler Configuration is Debug
- Building Settings. Select "Create VisualStudio Solution", and a source code project is included after publishing, which is available for testing.
- After the Build is completed, a debuggable project will be generated

For more information, please refer to [Unity Official Documentation](https://docs.unity3d.com/2020.3/Documentation/Manual/windowsstore-debugging-il2cpp.html)

### Android create debug project

- Prepare Unity 2020.3.33 version. According to your platform, the corresponding il2cpp module must be installed at the same time.
- Project Settings settings
   - Scripting Backend for IL2Cpp
   - C++ Compiler Configuration is Debug
- Building Settings. Select "Export Project", and a source code project will be included after publishing, which is available for testing.
- After the build is complete, use Android Studio to open the project. The following operations are all performed in Android Studio
- Assuming that the packaging output path is build_android, select Build->Make Module 'build_android.unityLibrary' in Android Studio, compile unityLibrary, and wait for the compilation to complete
- Select Run->Edit Configurations...; set as shown below

::: center
  ![android studio debug](/img/hybridclr/android_studio_debug.png)
:::

- Normal debug can be used to breakpoint, the source code path is as follows.

::: center
  ![android studio debug](/img/hybridclr/android_studio_project.png)
:::
