---
title: AOT generic problem
date: 2022-05-25 11:50:18
permalink: /hybridclr/aot_generic/
categories:
  - HybridCLR
  - performance
tags:
  - 
author: 
  name: Code Philosophy
  link: https:://code-philosophy.com
---

# AOT generic problem

There are two types of generic features in the CLR: generic types and generic functions. Generics are an extremely widely used feature in C#. Even a usage that does not explicitly contain generics may imply generic-related definitions or operations.

In the CLR, a new instantiation of a generic type implies the need to create metadata about the generic instantiation type in memory. For the generic class defined in **hot update code**, HybirdCLR naturally supports its generic instantiation, but for the instantiation of **AOT generic**, some problems are encountered.

il2cpp is an AOT runtime, and almost all (why not all?) types used in its runtime are statically determined at compile time. You have only instantiated `List<int>` and `List<string>` in AOT, you cannot use code like `new List<float>()` in hot update code.

Although il2cpp can create most of the metadata of the `List<float>` type in memory, it cannot create its member function implementations.
You can get `typeof(List<float>)` through reflection, but you cannot call any of its member functions, including constructors.

The essential reason why member function implementations of AOT generic types cannot be created is that il2cpp loses the original IL function body information after converting IL to c++ code.
As a result, the implementation of each member function of `List<float>` cannot be instantiated according to the metadata of the generic base class `List<>`.

Generic classes, especially generic containers such as List and Dictionary are widely used in the code. If List&lt;HotUpdateType&gt; and the like cannot run due to AOT restrictions, then the code restriction for game hot update is too large. Fortunately, HybridCLR completely solves this problem using two types of techniques:

- `Generic sharing` technology based on il2cpp
- Based on `Supplementary Metadata` technology, which is also HybridCLR's patented technology

## Generic sharing mechanism of il2cpp

In order to avoid generic code expansion and save memory, il2cpp generates only one code for some codes that can be shared while ensuring the correctness of code logic. To introduce a concept called **generic code sharing** [Generic Sharing](https://blog.unity.com/technology/il2cpp-internals-generic-sharing-implementation), this technology originated from mono earlier . The same concept exists in the CLR. The CLR considers that all reference type actual parameters are the same, so code can be shared. For example, the code compiled for the List&lt;String&gt; method can be directly used for the List&lt;Stream&gt; method, because all reference type actual parameters The parameter/variable is just an 8-byte pointer pointing to the managed heap (64-bit system is assumed here), but for value types, code generation must be performed for each type, because the size of the value type is variable.

  Take List&lt;T&gt; as an example:

- You can use any instantiation type of List used in AOT. For example, if you have used List&lt;vector3&gt; in AOT, you can also use it in hot update
- Any List&lt;HotUpdateEnum&gt; can be used. You only need to instantiate a certain List&lt;enumeration type of the same underlying type&gt; in AOT.
- The generic parameter List&lt;HotUpdateClass&gt; of any reference type can be used. You only need to instantiate List&lt;object&gt; (or any reference generic parameter such as List&lt;string&gt;) in AOT

### Shared type calculation rules

Assuming that the shared type of the generic class T is share type, the calculation rules are as follows:

#### Non-enumeration value types

The share type is itself. For example, the share type of int is int

#### Enum Type

The share type is an enumeration whose underlying type is the same as it. E.g

```csharp
enum MyEnum 
{
    A = 1,
}
enum MyEnum2 : sbyte
{
    A = 10,
}
```

Since the default underlying type of enum is int, the share type of MyEnum is Int32Enum, and the share type of MyEnum2 is SByteEnum. Note that there are no types such as Int32Enum and SByteEnum in the CLI, you need to create such an enumeration type in your AOT in advance.

#### class reference type

share type is object

#### Generic Types

GenericType&lt;T1,T2,...&gt; If it is a class type, the share type is object, otherwise the share type is GenericType&lt;shareType&lt;T1&gt;, shareType&lt;T2&gt;...&gt;.

E.g

- The share type of Dictionary&lt;int, string&gt; is object.
- The share type of YourValueType&lt;int, string&gt; is YourValueType&lt;int, object&gt;

### Shared generic function calculation rules for generic functions

The AOT generic function for `Class<C1, C2, ...>.Method<M1, M2, ...>(A1, A2, ...)` is
`Class<share(C1), share(C2), ...>.Method<share(M1), share(M2), ...>(share(A1), share(A2), ...)`

- `List<string>.ctor` corresponds to the shared function `List<object>.ctor`
- `List<int>.Add(int)` corresponds to the shared function `List<int>.Add(int)`
- The shared function of `YourGenericClass<string, int, List<int>>.Show<string, List<int>, int>(ValueTuple<int, string>, string, int)` is `YourGenericClass<object, int, object >.Show<object, object, int>(ValueTuple<int, object>, object, int)`


### The reason why the value type in il2cpp does not support generic sharing

It is easy to understand that value types of different sizes cannot be shared, but why can't value types of the same size be shared generically like a class? There are two main reasons.

#### Problems caused by memory alignment

Even if the value types have the same size, if the alignment is different, when they are used as subfields of other classes, the memory size and layout of the final class may be different.
In addition, when passing parameters to functions under different ABIs, aligment will also lead to different ways of passing parameters. E.g:

```csharp
struct A // size = 4, alignment = 2
{
    short x;
    short y;
};

struct B // size = 4，alignment = 4
{
    int x;
};

struct GenericDemo<T>
{
    short x;
    T v;

    public T GetValue() => v;
};

```

`GenericDemo<A>` size=6, alignment=2, field v is offset by 2 in the class; and `GenericDemo<B>` size=8, alignment=4, field v is offset by 4 in the class. Obviously, for the GetValue function, due to the different offsets of v, it is impossible to use the same set of c++ codes to work correctly for these two classes.

#### ABI issues

Structures of the same size and alignment are equivalent in [x64 ABI](https://docs.microsoft.com/zh-cn/cpp/build/x64-software-conventions?redirectedfrom=MSDN&view=msvc-170) , you can use structures of the same size for shared generic instantiation. But it doesn't work in [arm64 ABI](https://docs.microsoft.com/zh-cn/cpp/build/arm64-windows-abi-conventions?view=msvc-170).

`struct IntVec3 { int32_t x, y, z; }` and `struct FloatVec3 { float x, y, z}` are both 12 in size, but when they are passed as function parameters, the way of passing parameters is different:

- IntVec3 is passed by reference
- The three fields of FloatVec3 are placed in three floating-point registers respectively

This is another key reason why structs cannot be shared generically.

### AOT generic problems caused by mechanisms such as async and IEnumerable

The compiler may generate implicit AOT generic references for complex syntactic sugar such as async. Therefore, in order for these mechanisms to work properly, the AOT generic instantiation problems caused by them must also be resolved.

Taking async as an example, the compiler generates several classes, state machines and some codes for async. These hidden generated codes contain calls to multiple AOT generic functions. The common ones are:

- `void AsyncTaskMethodBuilder::Start<TStateMachine>(ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder::AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder::SetException(Exception exception)`
- `void AsyncTaskMethodBuilder::SetResult()`
- `void AsyncTaskMethodBuilder<T>::Start<TStateMachine>(ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder<T>::AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder<T>::SetException(Exception exception)`
- `void AsyncTaskMethodBuilder<T>::SetResult(T result)`



Use the standard method of solving AOT generics to solve these problems. It is strongly recommended to use the Supplementary Metadata mechanism.

You can also use the generic sharing mechanism, that is, instantiate these functions in advance in AOT, but **Note**, the state machine generated by the c# compiler in release mode is of the ValueType type, which makes it impossible to share generic types, but debug The state machine generated in the mode is of class type and can be shared generically. Therefore, if you use the generic sharing mechanism, in order to use the async syntax in the hot update, you must add the `scriptCompilationSettings.options = ScriptCompilationOptions.DevelopmentBuild;`  code when using the script to compile the dll, so that the compiled state machine is of class type and can work normally in the hot update code. If `Supplementary Metadata Technology` has been used, due to full support for AOT generics, there are **unlimited** compilation methods.

It is **STRONGLY** recommended to use the Supplementary Metadata mechanism with the DevelopmentBuild option turned off.

### AOT generic instantiation example

#### Example 1

error log

```csharp
MissingMethodException: AOT generic method isn't instantiated in aot module 
  void System.Collections.Generic.List<System.String>.ctor()
```

You add a call to `List<string>.ctor()` in RefType, which is `new List<string>()`. Thanks to the **generic sharing mechanism**, you just call `new List<object>()`.

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      new List<object>(); // 也可以用 new List<string>()
  }
}
```

#### Example 2

error log

```csharp
MissingMethodException: AOT generic method isn't instantiated in aot module 
    void System.ValueType<System.Int32, System.String>.ctor()
```

Notice! The empty constructor of the value type does not call the corresponding constructor, but corresponds to the initobj instruction. In fact, you can't directly reference it, but you just need to force the instantiation of this type, and all functions of the preserve class will naturally include the .ctor function.

In practice you can use forced boxing `(object)(default(ValueTuple<int, object>))`.

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      // 以下两种写法都是可以的
      _ = (object)(new ValueTuple<int, object>());
      _ = (object)(default(ValueTuple<int, object>));
  }
}
```

#### Example 3

error log

```csharp
MissingMethodException: AOT generic method isn't instantiated in aot module 
  System.Void System.Runtime.CompilerService.AsyncVoidMethodBuilder::Start<UIMgr+ShowUId__2>(UIMgr+<ShowUI>d__2&)
```

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      var builder = new System.Runtime.CompilerService.AsyncVoidMethodBuilder();
      IAsyncStateMachine asm = default;
      builder.Start(ref asm);
  }
}
```

### Defects of the generic sharing mechanism

Since value types cannot be shared generically, if a value type appears in the generic parameter of a generic instance (class or function), this generic instance must be instantiated in advance in AOT. if
Your generic parameter type is the value type defined in the hot update code. Since the hot update type is obviously impossible to instantiate generics in AOT in advance, you are hot updating the code
Codes such as `List<hot update value type>` cannot be used in , which brings great inconvenience to development.

Fortunately, we innovatively proposed the patented `Supplementary Metadata` technology, which completely solved this problem.

## Generic function instantiation technology based on supplementary metadata (HybridCLR's patented technology)

The problem that AOT generic functions cannot be instantiated is essentially because the original MethodBody IL metadata is lost during the translation of `IL -> C++` by il2cpp. The solution is very thorough - supplement the lost original MethodBody IL metadata.

Note that it is the generic function that loses the IL function body metadata, not the generic parameter type that loses metadata. Take `var a = new List<YourValueType>()` as an example,
It is the `List<T>.ctor` (the class constructor name in the CLI is called .ctor) function that is missing the original IL function body metadata, not `YourValueType` that is missing the metadata. therefore
Supplementary metadata should supplement the aot dll where the generic class is located, for example, the dll where `List<T>` is located is `mscorlib`, not the dll where `YourValueType` is located.

Use the `HybridCLR.RuntimeApi.LoadMetadataForAOTAAssembly` function in the hybridclr_unity package to supplement the corresponding metadata for the AOT assembly.
The LoadMetadataForAOTAssembly function can be called at any time. In addition, it can be called in AOT or hot update. You just need to call it before using AOT generics (only need to call it once).

In theory, the earlier the loading, the better. In practice, the more reasonable time is after the hot update is completed, or after the hot update dll is loaded but before any code is executed. If the dll that supplements the metadata is also entered into the main package as an additional data file (for example, placed under StreamingAssets), then the loading of the main project is better when it starts.

**Supplementary metadata has no load order requirement**.

If the AOT generic supplements the corresponding generic metadata, and il2cpp generic sharing instantiation also exists, in order to maximize performance, HybridCLR will give priority to il2cpp generic sharing.

Although the generic function instantiation technology based on supplementary metadata is quite perfect, after all, the instantiated function is executed in an interpreted manner. If the generic instantiation in AOT can be performed in advance, the performance can be greatly improved.
Therefore, it is recommended to instantiate in AOT in advance for commonly used, especially performance-sensitive generic classes and functions. We provide tools to help automatically scan and collect corresponding generic instances, you can run the menu command `HybridCLR/Generate/AOTGenericReference`.

### Metadata Mode HomologousImageMode

Two metadata schemas are currently supported:

- `HomologousImageMode::Consistent` mode, that is, the supplementary dll is exactly the same as the cropped dll when packaging. Therefore, the clipped dll generated during the build process must be used, and the original dll cannot be copied directly. We added processing code in `HybridCLR.BuildProcessors.CopyStrippedAOTAssemblies` to automatically copy these clipped dlls to the `{project}/HybridCLRData/AssembliesPostIl2CppStrip/{target}` directory when packaging.
- `HomologousImageMode::SuperSet` mode, that is, the supplementary dll is a superset of the trimmed dll when packaging, and contains all the metadata of the trimmed dll. One of the easiest superset dlls to get is the original aot dll, which is also the recommended superset dll. Please refer to the detailed documentation for the location of the original aot dll.

For detailed documentation, see [hybridclr_unity](/en/hybridclr/hybridclr_unity/).


### Load supplementary metadata sample code

See the sample code below for how to load the supplementary metadata dll in the code, and you can also refer to [hybridclr_trial](https://github.com/focus-creative-games/hybridclr_trial).

```csharp
    public static unsafe void LoadMetadataForAOTAssembly()
    {
        List<string> aotDllList = new List<string>
        {
            "mscorlib.dll",
            "System.dll",
            "System.Core.dll", // 如果使用了Linq，需要这个
            // "Newtonsoft.Json.dll",
            // "protobuf-net.dll",
        };

        AssetBundle dllAB = LoadDll.AssemblyAssetBundle;
        foreach (var aotDllName in aotDllList)
        {
            byte[] dllBytes = dllAB.LoadAsset<TextAsset>(aotDllName).bytes;
              int err = HybridCLR.RuntimeApi.LoadMetadataForAOTAssembly(dllBytes, HomologousImageMode.SuperSet);
              Debug.Log($"LoadMetadataForAOTAssembly:{aotDllName}. ret:{err}");
        }
    }
```

## `full generic share` technical supplementary introduction

Since the 2021.3.x LTS version, il2cpp has fully supported the `full generic share` technology. When the `Il2Cpp Code Generation` option in Build Settings is `faster runtime`, it is the generic sharing mechanism introduced in the previous chapter, which is `faster(smaller ) build` on
`full generic share` mechanism.

When `full generic share` is enabled, each generic function (regardless of whether the generic parameter is a value type or a class type) will completely share a code. The advantage is that the code size is saved, and the disadvantage is that it greatly hurts the performance of the generic function. The fully generic shared code is sometimes several to ten times slower than the standard generic shared code, and even worse than the purely interpreted version. Therefore it is strongly recommended to **not enable** the `faster(smaller) build` option. Because of this, although HybridCLR can work with the `full generic share` mechanism, it does not take advantage of this mechanism at all. Because this mechanism has basically no practical significance except when you want to reduce the inclusion extremely.
