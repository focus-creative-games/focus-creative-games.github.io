---
title: Memory-related principles
date: 2022-05-25 11:50:18
permalink: /hybridclr/memory/
categories:
    - HybridCLR
tags:
    -
author:
    name: Code Philosophy
    link: https:://code-philosophy.com
---

# Memory-related principles

HybridCLR is implemented at the CLR level, so the hot update script, except that the execution code is executed in interpreted mode, is completely the same as the AOT part.

## object memory size

For value types, the object size is not simply the size occupied by all members, memory alignment must be considered. For reference types, there is an extra object header (16 bytes), and the memory alignment is 8 bytes. For array types, it is more complicated.

### primitive type

Such as byte, int. As we all know, byte occupies 1 byte, int occupies 4 bytes, and others are not described in detail.

### struct value type

In the case where Explicit Layout is not specified, the total size is calculated according to the field size and memory alignment rules, which is similar to the struct calculation rules of C++. I wonâ€™t elaborate here, just give an example.

```csharp
// V1 object size 1
struct V1
{
    public byte a1;
}

// V2 object size 8
struct V2
{
    public byte a1;
    public int a2;
}

// V3 object size 24
struct V3
{
    public int a1;
    public int a2;
    public object a3;
    public byte a4;
}
```

### class type

Similar to the value type, but with 16 bytes of object header, and enforces memory alignment to 8 bytes. Example:

```csharp
// C1 object size 24
class C1
{
    public byte a1;
}
// C2 object size 24
class C2
{
    public byte a1;
    public int a2;
}
// C3 object size 40
class C3
{
    public int a1;
    public int a2;
    public object a3;
    public byte a4;
}
```

## Compared with the object memory size of lua and ILRuntime

The calculation rules of lua are slightly complicated, see [third-party article](https://www.linuxidc.com/Linux/2018-10/154971.htm). An empty table occupies 56 bytes, and each additional field occupies at least 32 bytes.

The type of ILRuntime is expressed in IlTypeInstance except enum. The empty type occupies 72 bytes, and each additional field uses at least 16 bytes. If the object contains reference type data, there will be at least 24 bytes more overall, and each additional object field will add 8 bytes.

|type | Xlua | ILRuntime | HybridCLR |
|:---:|:---:|:---:|:---:|
|V1|88| 88 | 1|
|V2|120|104|8|
|V3|184|168|24|
|C1|88| 88 | 24|
|C2|120|104|24|
|C3|184|168|40|

## GC during operation

HybridCLR is implemented strictly according to the specifications. Except that the additional CPU and memory will be consumed when the assembly is loaded and the function is transferred for the first time, the memory consumed at runtime is exactly the same as that of il2cpp.

So you don't have to ask questions such as whether `foreach loop will generate GC`. How many GCs are generated under il2cpp or mono, and the exact same GCs are also generated when interpreted and executed in HybridCLR.
