---
title: About gidb
date: 2022-05-25 11:14:58
permalink: /gidb/about/
categories:
  - gidb
tags:
  - 
editLink: false
author: 
  name: Code Philosophy
  link: https:://code-philosophy.com
---


# gidb

The core design goal is a solution for **high performance stateless game system functions**, which achieves performance close to local memory transactions, and the performance data exceeds the conventional `stateless server + redis` by more than an order of magnitude.

## Link

- [gidb github](https://github.com/focus-creative-games/gidb)

## Features

- Provides an easy-to-use object database interface
- Realize high-performance CRUD distributed transactions, and the performance is close to that of local memory transactions without competition. Distributed transactions solve the pain points of data consistency under the distributed series of most games
- Based on the optimistic locking deadlock-free transaction mechanism, the redo mechanism has been deeply improved, and the transaction can be completed within 2 times under severe competition conditions, avoiding the large performance degradation caused by starvation and fierce conflicts
- Real-time incremental persistence, the player's home is saved, no more data loss
- High concurrency, high availability, high reliability

## Use display

### Two nodes, execute at the same time to give character 1001 experience +1. The final result is character experience +2

```csharp
    async Task<bool> Handle_AddPlayerExpAsync(PlayerTxnContext ctx)
    {
        db.User user = await db.user.TbUser.GetAsync(1001);
        user.Exp += 1;
        return true;
    });
```


### Role 1001 send 100 ingots to role 1002

```csharp
    async Task<bool> Handle_TranferMoneyAsync(PlayerTxnContext ctx)
    {
        db.User user1 = await db.user.TbUser.GetAsync(1001);
        user1.Gold -= 100;
        db.User user2 = await db.user.TbUser.GetAsync(1002);
        user2.Gold += 100;
        return true;
    }
```

### The character 1002 and 1002 form a couple, and the character 1001 consumes 100 ingots


```csharp
    async Task<bool> Handle_EngageAsync(PlayerTxnContext ctx)
    {
        db.User user1 = await db.user.TbUser.GetAsync(1001);
        if (user1.Gold < 100)
        {
            ctx.ResponseError(ErrorCode.GOLD_NOT_ENOUGH);
            return false;
        }
        // Note that although the money is deducted first, if the subsequent check meets the conditions and the transaction fails, it will be automatically rolled back.
        // In many cases, it has great convenience and reduces the mental burden of programmers.
        user1.Gold -= 100;
        
        db.Lover lover1 = await db.sns.TbLover.GetAsync(1001);
        if (lover1.LoverId != 0)
        {
            ctx.ResponseError(ErrorCode.YOU_HAVE_LOVER);
            return false;
        }
        db.Lover lover2 = await db.sns.TbLover.GetAsync(1002);
        if (lover2.LoverId != 0)
        {            
            ctx.ResponseError(ErrorCode.PEER_HAVE_LOVER);
            return false;
        }
        lover1.LoverId = 1002;
        lover2.LoverId = 1001;
        return true;
    }
```

### Remove the first member from the team

```csharp
    // Any operation on some data can be executed on any node, even concurrently, and the correct result can be obtained.
    // Demonstrate the operation of a captain kicking the first member of the team (didn't check the boundary conditions carefully, please ignore these details).
    async Task<bool> Handle_KickTeamMemberAsync(PlayerTxnContext ctx)
    {
        // The lock granularity of bright db transactions is row (that is, a record in the table)
        // The order of the following access records is user1, team, user2.
        // If the database is implemented based on pessimistic locking, there is a potential deadlock risk.
        // And bright db can guarantee no deadlock, and can complete the transaction within 2 times in the case of fierce conflicts (excellent!!!!!!)
        db.User user = await db.user.TbUser.GetAsync(1001);
        db.Team team = await db.team.TbTeam.GetAsync(user.TeamId);
        long kickedUserId = team.Members[0].UserId;
        // Remove the first member from the queue
        team.Members.RemoveAt(0);
        db.User kickedUser = await db.user.TbUser.GetAsync(kickedUserId);
        // For kicked roles, set team id=0
        kickedUser.TeamId = 0;
        return true;
    }
```

## Support and Contact
    
     QQ group: 732436871 GiDB development group

## license

Luban is licensed under the [MIT](https://github.com/focus-creative-games/luban/blob/main/LICENSE) license
