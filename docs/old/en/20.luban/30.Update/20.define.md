---
title: Data definition—xml
date: 2022-05-25 11:14:58
permalink: /luban/define/
categories:
  - luban
tags:
  - 
author: 
  name: Code Philosophy
  link: https:://code-philosophy.com
---
# Introduce

Definitions consist of two types of files

- root definition file
   The file name is generally root.xml or \_\_root\_\_.xml. Including topmodule, branch, group, import, service and other setting items.
- subdefinition file
   Contains configuration table related definitions. Including table, bean, enum definition. The configuration table definition can be configured in xml or in an excel file. Each item can be freely selected according to preference, and can even exist at the same time.

## root definition file

root.xml is the root file of the definition, and luban obtains all definition-related data directly and indirectly from root.xml. Some generated setting parameters are defined in root.xml, and through import and importexcel
Indicates the definition file related to the specific configuration table definition.

root.xml contains the following settings:

### topmodule

Specifies the top-level namespace. Add this top-level namespace for all generated code classes to avoid definition conflicts between generated code and other code.

The topmodule parameter is optional and is empty by default. However, the generally recommended value is cfg.

```xml
<topmodule name="cfg"/>
```

### option

Specify some additional custom options or parameters. option can have 0 or more.

```xml
  <option name="platform" value="win"/>
  <option name="editor.topmodule" value="editor.cfg"/>
```

Both name and value are mandatory parameters.

The option parameter can be accessed in code and data scriban templates.

- has_option 'xxx' checks if the corresponding option exists.
- get_option 'xxx' Get the value corresponding to an option.
- get_option_or 'option_name' 'default_value' Get the value of an option, if it does not exist, take the default value

Currently some internal options have been defined

- editor.topmodule The top-level namespace of code generated by cs_unity_editor_json, the default is editor.{top_module}
- cpp_bin.output_all_types_file The name of the file containing all types output by cpp_bin, the default gen_types.h
- cpp_bin.type_per_stub_file cpp_bin The number of types each stub file contains. default 100
- cpp_bin.stub_file_name_format cpp_bin stub file format. Default gen_stub_{0}.cpp
- cpp_ue_editor_json.type_per_stub_file cpp_ue_editor_json The number of files contained in each stub file, the default is 200
- cpp_ue_editor_json.stub_file_name_format The stub file name format of cpp_ue_editor_json, the default is gen_stub_{0}.cpp


### patch

For localization, make nuanced multi-locale configuration data. There can be 0 or more.

```xml
<patch name="cn"/>
<patch name="en"/>
```

### group

In actual projects, it is often necessary to specify that the fields in a certain table or bean are only exported to the server or client, and the grouping mechanism is used to solve this problem. Grouping at two granularities is currently supported: table-level grouping and field-level grouping.

group is used to define a group, and the group specified in the configuration table definition must be the group defined in root.xml in advance. There can be 0 or more groups. In actual game projects, at least two groups c and s are generally defined.

The default participation is used to indicate whether the table belongs to this group by default if the group is not specified. default=1 indicates that the table with no group attribute is set, and belongs to this group by default.

```xml
<group name="c" default="1"/>
<group name="s" default="1"/>
<group name="e" default="1"/>
```

### import

Import a subdefinition file in xml format. That is, it can be a specific xml file or a directory (automatically traverse the directory tree and load all xml definitions). There can be 0 or more.

```xml
<import name="item.xml"/>
<import name="."/>
```

### importexcel

Import a subdefinition file in excel format. Different from the xml definition file, the xml definition file can contain enum, bean, and table definitions at the same time, while the definition file in excel format is divided into enum, bean, and table accordingly
Three types, each type of file can only define one structure. There can be 0 or more definition files for each type.

- The name attribute specifies the name of the imported excel definition file. Note that in theory, for uniformity, the excel definition file should be placed in the definition directory, but in order to take care of the habits of most users, the definition file
The search path is the directory specified by the --input_data_dir option.

- The type attribute specifies the definition category. Optional enum, bean, table.

```xml
<importexcel name="bean.xlsx" type="bean"/>
<importexcel name="enum.xlsx" type="enum"/>
<importexcel name="table.xlsx" type="table"/>
```

### externalselector

There can be multiple selectors for external classes. The selector is used to indicate which mapper is selected for a class that defines an externaltype.

For example, if you define the Color class, you can define that when the selector is unity, the Color class is mapped to the UnityEngine.Color class for easy use. while the server does not
If the selector parameter is specified, the generated Color class is still used.

```xml
<externalselector name="unity"/>
<externalselector name="cocos"/>
```

### service

service is the export target. The -s(--service) parameter in the command line parameters refers to it. A project generally includes at least three export targets: client, server, and all.

- name indicates the service name. can be defined arbitrarily.
- manager indicates the name of the generated Tables class that contains all tables. Generally take Tables.
- group indicates which groups are included in the export destination.
- server.ref is used to force reference to certain classes. Not all defined types will generate code. By default, only the types that are directly or indirectly referenced by the exported table will be generated. If you want to export a table that is not referenced, but want to generate code for it
type, you can specify a mandatory reference in ref. For example, in the example below, xxx.ServerOnlyType1 and xx.ServerOnlyEnum1 must be exported.

```xml
<service name="server" manager="Tables" group="s">
    <ref name="xxx.ServerOnlyType1"/>
    <ref name="xxx.ServerOnlyEnum1"/>
</service>
<service name="client" manager="Tables" group="c"/>
<service name="all" manager="Tables" group="c,s,e"/>
```

## xml sub definition file

Can contain module, bean, enum, table these definitions.

A typical table definition is as follows:

```xml
<module name="item">
   <enum name="xxx">

   </enum>

   <bean name="yyyy">
   
   </bean>

   <table name="Tbzzz" value="xxx" input="abc.xlsx"/>
</module>
```

### module definition

The name attribute is the module name. It can be empty or a multi-level module name, such as xx.yy. Modules can be nested to define submodules, and submodules will inherit the namespace of the parent module. For types defined in a module, the namespace is the full name of the module.
For example, the full name of the Abc class below is xx.yy.Abc, and the name of the Def class is xx.zz.Def.

```xml
<module name="xx">
   <module name="yy">
     <bean name="Abc"/>
   </module>
   <module name="zz">
     <bean name="Def"/>
   </module>
</module>
```

### refgroup definition

Define a ref group. Sometimes many fields will refer to a common set of tables. It is more convenient to use refgroup, and there is no need to modify multiple places when modifying.

```xml
<refgroup name="xxx" ref="xx.Tbxx,yy.Tbyy,..."/>

```

- refgroup.name. required. Reference the group name. It needs to be globally unique and does not contain the module name.
- refgroup.ref. required. The referenced table name. The format is exactly the same as for ref validators.

### enum definition

Define an enumeration. The format is as follows.

```xml
<enum name="Color">
    <var name="RED" alias="红" value="1"/>
    <var name="GREEN" alias="绿" value="2"/>
   <var name="BLUE" alias="蓝" value="3"/>
</enum>

<enum name="AccessMode" flags="1" tags="key1=value1#key2=value2" comment="访问方式" unique="1">
    <var name="READ" value="1" tags="key1=value1#k2=v2" comment="读"/>
    <var name="WRITE" value="2"/>
    <var name="READ_WRITE" value="READ|WRITE"/>
</enum>
```

Grammar introduction:

- enum.name. Required. enum name. The namespace is the complete namespace of the current module (including the parent module).
- enum.flags. Optional. Whether it is a bit flag type. The default is false. If it is 1 or true, it is allowed to use READ|WRITE when filling in the configuration data
- enum. tags. Optional. Label. The format is "key1=value2#key2=value2#...". Generally, it may be used when generating custom templates. See the section **Defining Tags** for details.
- enum. unique. Optional. Whether the enumeration value is unique. The default is true.
- enum.comment. Optional. note. If non-empty, comments are included when generating code.
- enum.var.name is required. enum name.
- enum.var.alias Optional. alias. When planning to fill in the data, you can fill in the alias, which is convenient for some plans with poor English.
- enum.var.value Optional. enumeration value. If not filled, the value is the value of the previous enumeration item +1. If it is the first enumeration item, the value is 0.
- enum.var.tags Optional. Label. It is generally only possible to use it when it is generated with a custom template. See the section **Defining Tags** for details.
- enum.var.comment Optional. note. If non-empty, comments are included when generating enumeration items. If it is empty and alias is defined, alias will be taken as a comment.

Planning In the configuration table, you can fill in the corresponding enumeration item name, alias or corresponding integer value to express this enumeration. **It is strongly recommended not to use integer values**.

### bean definition

Define a struct type. There are two types of structures, ordinary structures and polymorphic structures.

#### Normal format

It must contain at least one field (the number of fields is not allowed to be 0, avoiding the situation where data such as lists and beans are read indefinitely). The format is as follows:

```xml

<bean name="Item" sep="," parent="">
   <var name="item_id" type="int" ref="item.TbItem"/>
   <var name="num" type="int" group="s"/>
   <var name="icon" type="string" path="unity"/>
   <var name="desc" type="string" tag="a=1#b=2"/>
</bean>
```

- bean.name The structure name. Cannot contain namespaces, e.g. abc.Item is not allowed.
- bean.parent Inherited parent class name. Optional parameter. Default is empty. Can inherit the type of other modules, at this time parent must write the full name.
- bean.sep Optional parameter. Specify that in the excel data source, the structure is filled in composite mode. For example, MyIntVector3 contains three int fields x, y, and z. If sep="," is used, all the read MyIntVector3 will be read in
Use ',' to split the string into three integers, and then read it in.
- var.name Field name. There are no special requirements, but it is recommended to use a name like xx_yy_zz, because when generating code, a field name that conforms to the language-recommended code style will be generated by default according to the language. Some names are reserved and not allowed, such as base, end, if, etc., because they are reserved words or keywords in some languages. If such names are misused, there will be compilation errors.
- var.type Type name. See the **Type Definition** section below.
- var.group The group to which var.group belongs. Optional. Can be multiple, separated by ',', each value must be one of the groups defined in root.xml, if not filled, the field belongs to all groups. See the section **Group Export** for details.
- var.ref Table reference. optional. Points to a full table name or a **refgroup**. Will check if this field is a valid id for a table. Mistakes in planning can be avoided. See the section **processor** for details.
- var.path Resource reference. optional. Points to a resource name. It will check whether this field points to a valid resource to avoid runtime errors caused by planning errors. See the section **processor** for details.
- var.tag Field tag. optional. The format is tag="tag1=xxx#tag2=bb#tag3=ccc". Used to add some tags to the fields. It is mainly used for special handling of some fields when customizing code generation. See the section **Definition Label** for details.

#### Polymorphic structures

In addition to defining its own subfields like ordinary structures, it can also contain 1 or more substructures at the end of the definition. Similar to the concept of OOP, the child structure will inherit all the fields of the parent structure. Substructures can either be ordinary
Structs can also be polymorphic structs. Polymorphic structure definitions that allow arbitrary inheritance hierarchies.

```xml
<bean name="Parent" >
   <var name="xxx" type="int"/>
   ... More parent class fields
   <bean name="Child11">
       <var name="x1" type="int"/>
       ... More fields for Child11

       <bean name="Child21">
         ... More fields for Parent21
       </bean>
       <bean name="Child22">
         ... More fields for Child22
       </bean>

       ... More direct subclasses of Parent11
   </bean>
   
  <bean name="Child12">
   ... Fields of Child12
  </bean>
</bean>

Define inheritance externally.
<bean name="Child31" parent="Parent">
  <var name="a" type="float"/>
  <var name="b" type="float"/>
</bean>

<module name="inner_module">
  It can be inherited from the parent class of other modules, and the parent is required to write the full name.
  <bean name="Child41" parent="test.Parent">
    <var name="a" type="float"/>
  </bean>
</module>
```

### table definition

Define a table. The format is as follows:

```xml
<table name="TbTableName" value="value_type" define_from_file="0" mode="map" input="file1,file2,..." group="group1,group2,..."/>
```

-name. Table Name. unlimited. But the format of TbXxxx is recommended.
- value. The structure type name of the table record.
- define_from_file Whether to read the definition of table record value from the file. optional. Default is false
- mode. table schema. Optional, defaults to map. Tables in three modes are currently supported.
   - map. Ordinary key-value table;
   - list. A table in list form. But it supports 0 to multiple indexes, and supports multi-primary key joint index and multi-primary key independent index.
   - singleton. It is a singleton table, suitable for defining some global information.
- input. Table data source. There can be more than one, separated by ','. Each data source can be a file, a directory, a cell in xlsx, a field in json, and so on.
-group. Table grouping. optional. Multiple values can be separated by ',', and each value must be one of the groups defined in root.xml. If not filled, this table belongs to the group with default=1 in the group defined in root.xml.

#### Table's mode details

Follow the description of mode in the table definition above. Because it is more critical, it is introduced independently.

- mode=map. Ordinary key-value table, if mode and index are not defined, it defaults to an ordinary table, and the first field of value_type is taken as key.

Definition table.

```xml
<table name="TbNormalMap" value="NormalMap" index="key1" input="normal_map.xlsx"/>
```

Sample data table.

|##var|key1|x|y| num|
|-|-|-|-|-|
|##type|int|long|string|int|
||1|1|aaa|123|
||2|1|bbb|124|
||3|2|aaa|134|
||4|1|aaa|124|
||5|6|xxx|898|

- mode=singleton. A singleton table, that is, a table with only one record, does not and cannot define an index attribute. For convenience, it can also be written as mode="one" or the like.

Definition table.

```xml
<table name="TbSingleton" value="Singleton" mode="singleton" input="singleton.xlsx"/>
```

|##var| guild_open_level | bag_init_capacity | bag_max_capacity | newbie_tasks |
| - |- | - | - | - |
| ##type | int | int | int | list,int|
| ## |desc1 | desc 2 | desc 3 | desc 4 |
| | 10 | 100| 500| 10001,10002 |

- mode=list，The number of keys is 0. No primary key list mode.

Definition table.

```xml
<table name="TbNotKeyList" value="NotKeyList" mode="list" input="not_key_list.xlsx"/>
```

Sample data table.

|##var|x|y|z| num|
|-|-|-|-|-|
|##type|int|long|string|int|
||1|1|aaa|123|
||1|1|bbb|124|
||1|2|aaa|134|
||2|1|aaa|124|
||5|6|xxx|898|

- mode=list, Joint multi-primary key mode. The number of keys >= 2.
Multiple keys form a joint unique primary key. Use "+" to split the key, indicating a joint relationship.

Definition table.

```xml
<table name="TbUnionMultiKey" value="UnionMultiKey" index="key1+key2+key3" input="union_multi_key.xlsx"/>
```

Sample data table.

|##var|key1|key2|key3| num|
|-|-|-|-|-|
|##type|int|long|string|int|
||1|1|aaa|123|
||1|1|bbb|124|
||1|2|aaa|134|
||2|1|aaa|124|
||5|6|xxx|898|

- mode="list", independent multi-primary key mode. The number of keys >=1, use "," to split the key, indicating the independent primary key mode, that is, each key is an independent and unique index.

Definition table.

```xml
<table name="TbMultiKey" value="MultiKey" index="key1,key2,key3" input="multi_key.xlsx"/>
```

Sample data table.

|##var|key1|key2|key3| num|
|-|-|-|-|-|
|##type|int|long|string|int|
||1|2|aaa|123|
||2|4|bbb|124|
||3|6|ccc|134|
||4|8|ddd|124|
||5|1|eee|898|

#### table.input data source details

The input attribute of the table specifies the data source, allowing multiple, separated by ",". Supports very flexible data source definitions:

- All cell sheets from an excel file. For example xxx.xlsx
- A specified cell sheet from an excel file. For example sheet@xxx.xlsx
- From json, xml, lua, yaml, unity scriptable asset files. For example xx.json or xx.xml or xx.lua or xx.yml
- from json, xml, lua, yaml, unity scriptable asset subfields. For example *items@item_module.json or item.consts@item_module.json etc., other formats are the same
- from the catalog. All files (including recursive subdirectories) under the directory tree will be read as data sources, and each file (except the excel family) corresponds to a record. For example skill_json_dir
- Any combination of the above. Such as xx.xlsx,sheet2@yy.xls,abc@zz.json,ccc_dir

### processor

For types, processor metadata can be attached. The processor serves two purposes:

- Validator. Such as ref, path, range, set, size.
- Special notes. Such as sep and so on.
- tag definition. Names other than the above two will be treated as tags.

#### Validators

The format is processor1=value1#processor2=value2 ...

Currently supported validators are ref, path, range, set, size, please refer to the document [Data Validator](/en/luban/advanced/validator/) for details.

#### Special Notes

Used to instruct luban to do special processing of data. Annotators are currently supported

- sep separator, the format is sep=list of chars. Can only be used to load excel data. Indicates that the next cell (or next character string) to be read is divided into multiple sub-data by any character in sep, and then these sub-data are read in as data of the current type. Generally speaking, only container types, bean types, and text types with multiple atomic data can use sep.

### Define tags

All defined processor=value data pairs will be maintained as a k-v tags dictionary. Tags are currently mainly used for custom code or data template generation. When you want to perform special processing on certain fields, tags can play a role.

The scriban template file provides two functions to manipulate tags.

::: v-pre

- {{has_tag ctype 'tag_name'}}  。 Check if a type has a certain tag
- {{get_tag ctype 'tag_name'}} 。 Returns the value corresponding to the tag of the type, or returns empty if it does not exist.
:::

### Data Labels

Note that it is different from defining tags. Definitions act on structure, field, table, etc. definitions, and data tags act on records. See [**tag**](/en/luban/tag/) for detailed documentation

Data labels currently serve several purposes:

- Record filtering

Add a tag to the record, which can be used for occasions such as filtering and exporting. For example, for data marked dev or debug, you can use --output:exclude_tags dev,test to filter out these data when it is officially released.

- unchecked flag

Identifies that no validator is to be performed on this record. During R&D, sometimes a batch of temporary data is planned and produced in batches. Many references are illegal and the program will not be used temporarily, resulting in a large number of warnings during generation. By adding unchecked to the data,
It is possible to have the validator not check the data validity of these records.

### Group export group

Currently supports group export at two granularities: table level and bean field level. Both table definitions and bean field definitions support the group attribute.

- table level export
If the group attribute of the table is not specified, it will export all groups with group.default=1 by default, and if specified, it will only export the specified group. There can be multiple groups.

The xml format is defined as follows.

```xml
<table name="TbClothDisplay" value="ClothDisplay" group="c" input="test/cloth.xlsx"/> This table only belongs to group c
<table name="TbItem" value="Item" group="c,s" input="test/item.xlsx"/> This table belongs to group c, s
<table name="TbWidget" value="Window" group="e" input="test/widget.xlsx"/> This table belongs to group e
```

The xlsx format is defined as follows

|##var| full_name| value_type| input| group | ... |
| - | - | - | -| - | - |
| | TbClothDisplay|ClothDisplay| cloth/cloth.xlsx |c||
||TbItem|Item|item/item.xlsx|c,s||
||TbWidget|Widget|ui/widget.xlsx|e||

When Luban.Client uses the -s client parameter, only the TbDemoGroup_C and TbDemoGroup_CS tables are exported, but the TbDemoGroup_E table is not exported.

- bean field level export

When exporting the configuration, a field in the bean is exported according to the group.

The xml definition format is as follows:

```xml

<bean name="DemoGroup">
 <var name="id" type="int"/>
 <var name="x1" type="int"/> Default belongs to all groups c, s, e
 <var name="x2" type="int" group="c"/>belongs to group c
 <var name="x3" type="int" group="s"/>belongs to group s
 <var name="x4" type="int" group="c,s"/>belongs to group c,s
</bean>
```

If the bean is defined in \_\_bean\_\_.xlsx, the format is as follows.
|##var|full_name|sep|comment| field.name |fields.type|field.group|...|
|-|-|-|-|-|-|-|-|
||DemoGroup|||id|int|||
|||||x1|int|||
|||||x2|int|c||
|||||x3|int|s||
|||||x4|int|c,s||

If the bean structure is defined directly in the data table, the format is as follows.
|##var|id|x1|x2|x3|x4|
|-|-|-|-|-|-|
|##type|int|int|int&group=c|int&group=s|int&group=c,s|
|| 1|2|2|2|2|

When -s client, the id, x1, x2, x4 fields are exported.
When -s server, the id, x1, x3, x4 fields are exported.

### External Types

Both enum and bean types support external types, and a custom type can be mapped to a ready-made class. Currently only supports the external type of c# language, and other languages will be extended when needed.

For example, you can define an AudioType that maps to UnityEngine.AudioType.

For example, you can define a Color class that maps to the UnityEngine.Color class.

Defined as follows.

```xml

External enum definition

    <enum name="AudioType">
        <var name="UNKNOWN" value="0"/>
        <var name="ACC" value="1"/>
        <var name="AIFF" value="2"/>
    </enum>
    
    <externaltype name="unity_audio_type" origin_type_name="test.AudioType">
        <mapper lan="cs" selector="unity_cs">
            <target_type_name>UnityEngine.AudioType</target_type_name>
        </mapper>
    </externaltype>

External class definition

    <bean name="Color" sep=",">
        <var name="r" type="float"/>
        <var name="g" type="float"/>
        <var name="b" type="float"/>
        <var name="a" type="float"/>
    </bean>
    <externaltype name="unity_color" origin_type_name="test.Color">
        <mapper lan="cs" selector="unity_cs">
            <target_type_name>UnityEngine.Color</target_type_name>
            <create_external_object_function>ExternalTypeUtil.NewFromCfgColor</create_external_object_function>
        </mapper>
    </externaltype>
```

Grammar introduction:

- externaltype.name. required. The external type name. This type name is not a real name, similar to the concept of id. Requires uniqueness within all definition files. It does not automatically add the module name.
- externaltype. origin_type_name. required. The mapped type **full name**.
- externaltype.mapper The mapper. For a class, some languages require mapping, and some languages may not require mapping. In addition, the mapping parameters of each language are different. So there may be more than one.
- mapper.lan. required. Only works for this language. It needs to cooperate with the selector to form a unique mapper.
- mapper. selector. required. Only generated for this selector. It needs to cooperate with lan to form a unique mapper.
- mapper.target_type_name is required. The full name of the mapped external type.
- mapper.create_external_object_function is optional when mapping an external enum, and is required for an external class. Conversion function name. A function needs to be provided to convert configuration class objects to external class objects.

For examples, see the example project [Csharp_Unity_bin_ExternalTypes](https://github.com/focus-creative-games/luban_examples/tree/main/Projects/Csharp_Unity_bin_ExternalTypes)

### type

Luban has a very complete type system that can easily express arbitrarily complex data structures.
#### Primitive Types

- bool
- byte(int8)
- short(int16)
- fshort
- int(int32)
- fint
- long(int64)
- flong
- float(float32)
- double(float64)
- string

#### bytes Types

That is, the byte array type. Corresponding to byte[] in c#.

#### vector2,vector2,vector3

Built-in vector types. In the c# language, it corresponds to System.Numerics.Vector{2,3,4}, or UnityEngine.Vector{2,3,4}.

- vector2 。 float x, y;
- vector3 。 float x, y, z;
- vector4 。 float x, y, z, w;

#### datetime (time) type

time type. After exporting the data, it will be converted to int type UTC time seconds since 1970-1-1 0:0:0.

Since the planning fills in the wall time (the period is related to the time zone), you need to specify the time zone corresponding to the datetime when exporting. If you don’t specify it, the East 8 time zone will be used by default.
See [Luban Command Line](/en/luban/command_tools/) for timezone related parameters.

#### text

Localized text type. It consists of two values, key and text.

#### Container Type

- array. Array type, defined as "array,element_type". The corresponding c# type is element_type[] and the like. For example array,int;array,Task.
- list. list type. Defined as "list,element_type". The corresponding c# type is List<element_type>. For example list,int;list,Item.
- set. collection type. Defined as "set,element_type". The corresponding c# type is HashSet<element_type>. For example set,int;set,string.
- map. Dictionary type. Defined as "map,key_type,value_type". The corresponding c# type is Dictionary<key_type, value_type>. For example map,int,int;map,string,Item;

The element_type of array and list can be any type except the container type, and nesting of container types is not supported, but you can define a bean to contain container fields. Then define the way of list and bean
Indirect implementation of container nesting.

The element_type of set must be native type, datetime, enumeration type, not bean type.

The key type constraint of the map is related to the element_type of the set, and the value type constraint is the same as the element_type of the array.

#### Nullable types

Corresponds to the semantics of nullable variables in c#, such as int?, bool? ColorType?. Types other than containers can define corresponding nullable types.

#### enum type

enumerated type.

```xml
<enum name="Color">
    <var name="RED" alias="红" value="1"/>
    <var name="GREEN" alias="绿" value="2"/>
   <var name="BLUE" alias="蓝" value="3"/>
</enum>

```

#### bean type

structure definition. There are two kinds of beans, common bean structure and polymorphic bean structure.

- Common bean structure

```xml
<bean name="Item" value_type="1" alias="道具">
    <var name="id" id="1" type="int" ref="item.TbItem" tags="k1=v1#k2=v2"/>
    <var name="icon" type="string" path="unity" comment="图标" group="c"/>
    <var name="num" type="int" group="c,s"/>
</bean>

```

- polymorphic bean structure

```xml

<bean name="Shape">
  <var name="command_var1" type="int"/>
   
  <bean name="Shape2D">
     <var name="command_2d_var" type="string"/>
      <bean name="Circle">
         <var name="radius" type="float"/>
      </bean>
      <bean name="Rectangle">
         <var name="width" type="float"/>
         <var name="height" type="float"/>
     </bean>
  </bean>

  <bean name="Line">
     <var name="start_pos" type="vector2"/>
     <var name="direction" type="vector2"/>
  </bean>
</bean>

Or define inheritance outside.

<bean name="Triangle" parent="Shape">
  <var name="a" type="float"/>
  <var name="b" type="float"/>
  <var name="c" type="float"/>
</bean>

```

## excel sub-definition file

The excel sub-definition file is almost completely equivalent to the xml definition file. For luban, it is only the difference in which format the file is parsed and read from.

Please refer to \_\_enums\_\_.xlsx, \_\_beans\_\_.xlsx, \_\_beans\_\_.xlsx, \ _\_tables\_\_.xlsx.

The excel sub-definition file is almost completely equivalent to the xml sub-definition file (except that the mapping information of the external class, that is, externaltype), is not defined. For luban, the difference between them is only the format of the definition, but the metadata provided is equivalent.

::: tip
Here we only introduce the format of the excel definition file, **For specific semantics, please refer to the relevant documents in the xml sub-definition file**
:::

The xml sub-definition file can define any structure, but excel is not suitable for defining various structures in one file, so the excel sub-definition file is divided into types, and each type only defines one structure. Each type can have 0 or more definition files (multiple importexcel statements, not multiple files in the name).

Since most users who use excel files to define configurations, for the sake of convenience, they want to define excel files in the configuration data directory, instead of the same as other definitions. In the configuration definition directory, special processing is specially made, with %input_data_dir% Read in excel definition files for relative directories.

There are three types of definition files:

- enum
- bean
- table

```xml

<importexcel name="__enums__.xlsx" type="enum"/>
<importexcel name="__beans__.xlsx" type="bean"/>
<importexcel name="__tables__.xlsx" type="table"/>

```

### enum definition file

Define multiple enum structures.

The format is as follows.

<div class="Excel">
<table border="1">
<tr align="center"><td>##var</td><td>full_name</td><td>flags</td><td>unique</td><td>comment</td><td>tags</td><td colspan="5">*items</td></tr>
<tr align="center"><td>##+</td><td/><td/><td/><td/><td/><td>name</td><td>alias</td><td>value</td><td>comment</td><td>tags</td></tr>
<tr align="center"><td/><td>test.ETestQuality</td><td>false</td><td>true</td><td/><td/><td>A</td><td>白</td><td>1</td><td>最差品质</td><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>B</td><td>黑</td><td>1</td><td>最差品质</td><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>C</td><td>蓝</td><td>1</td><td>中等品质</td><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>D</td><td>红</td><td>1</td><td>最好品质</td><td/></tr>
<tr align="center"><td/><td>test.AccessFlag</td><td>true</td><td>true</td><td/><td/><td>WRITE</td><td></td><td>1</td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>READ</td><td></td><td>2</td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>TRUNCATE</td><td></td><td>4</td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>NEW</td><td></td><td>8</td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td></td><td/><td/><td>READ_WRITE</td><td></td><td>READ|WRITE</td><td></td><td/></tr>
</table>
</div>

### bean definition file

Define multiple bean structures. **Polymorphic bean** definitions are not supported.

The format is as follows.

<div class="Excel">
<table border="1">
<tr align="center"><td>##var</td><td>full_name</td><td>sep</td><td>comment</td><td>tags</td><td colspan="5">*fields</td></tr>
<tr align="center"><td>##+</td><td/><td/><td/><td/><td>name</td><td>type</td><td>group</td><td>comment</td><td>tags</td></tr>
<tr align="center"><td/><td>test.DemoBean1</td><td></td><td/><td/><td>x1</td><td>int</td><td></td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td/><td/><td>x2</td><td>string</td><td></td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td/><td/><td>x3</td><td>float</td><td></td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td/><td/><td>x4</td><td>bool</td><td></td><td></td><td/></tr>
<tr align="center"><td/><td>test.DemoBean2</td><td></td><td/><td/><td>x1</td><td>int</td><td></td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td/><td/><td>x3</td><td>list,float</td><td></td><td></td><td/></tr>
<tr align="center"><td/><td></td><td></td><td/><td/><td>x4</td><td>test.DemoBean1</td><td></td><td></td><td/></tr>
</table>
</div>

### table definition file

Defines a list of configuration tables, only tables appearing in this table will be exported.

value_type is the table record type class, which must be a bean structure. If the type name of value_type does not contain a module name, it will use the same namespace as full_name, and if it contains a module name, it will use this module name. For example, the module name of Item is item, and the module name of demo.Bag is demo.

The format is as follows.

<div class="Excel">

|##var|full_name|value_type|define_from_file|input|index|mode|group|comment|tags|patch_input|output|
|-|-|-|-|-|-|-|-|-|-|-|-|
||item.TbItem|Item|true|item.xlsx|||||||
||test.TbBag|demo.Bag|true|bag.xlsx|||||||

</div>