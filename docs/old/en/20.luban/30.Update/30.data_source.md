---
title: Other Data Sources
date: 2022-05-25 11:14:58
permalink: /luban/data_source/
categories:
  - luban
tags:
  - 
author: 
  name: Code Philosophy
  link: https:://code-philosophy.com
---

## Data definition

Most of the data format filling methods are intuitive, and the data definitions are exactly the same. The format examples of different data structures in xml are as follows:

```xml
<bean name="DemoType2" >
  <var name="x4" type="int" convert="DemoEnum"/>
  <var name="x1" type="bool"/>
  <var name="x5" type="long" convert="DemoEnum"/>
  <var name="x6" type="float"/>
  <var name="x7" type="double"/>
  <var name="x10" type="string"/>
  <var name="x12" type="DemoType1"/>
  <var name="x13" type="DemoEnum"/>
  <var name="x14" type="DemoDynamic" sep=","/>polymorphic data structure
  <var name="v2" type="vector2"/>
  <var name="v3" type="vector3"/>
  <var name="v4" type="vector4"/>
  <var name="t1" type="datetime"/>
  <var name="k1" type="array,int"/> Use; to separate
  <var name="k2" type="list,int"/>
  <var name="k8" type="map,int,int"/>
  <var name="k9" type="list,DemoE2" sep="," index="y1"/>
  <var name="k15" type="array,DemoDynamic" sep=","/> 
</bean>

<table name="TbDataFromSingle" value="DemoType2" input="test/datas"/> 
```

## Data source file

### Organize in the form of a directory tree

Typical usage is to use the directory as the data source (the entire directory tree will be traversed), and each file under the directory tree is read as a record. The following example traverses the entire directory tree recursively, and reads each file as a record after **sorting by file name**.

::: tip tip
When the data is mixed with json lua xml or other arbitrary source files, luban can load the data correctly
:::

1. Json data source features:

- set type. The filling method is [v1,v2,...]
- map type. Since json only supports keys of string type, the format of the map is [[k1,v1],[k2,v2]...]
- Polymorphic bean types. The $type attribute is required to specify the concrete type name
- text type, the filling method is {"key":key, "text":text}

2. Lua data source features:

- There is a return before the data, because the lua data is loaded as a lua file, and each loaded result is read as a record
- The format of the set is {v1, v2, ...}
- Unlike json, the key of lua's table supports any format, so lua's map can directly {[key1] = value1, [key2] = value2, ,,,}
- Polymorphic bean types. The \_type\_ attribute is required to specify a concrete type name
- text type, the filling method is {key = key, text = text}

The content of the sample configuration file is as follows
:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"
::: tab JSON 
```json
{
  "x1":true,
  "x2":3,
  "x3":128,
  "x4":1,
  "x5":11223344,
  "x6":1.2,
  "x7":1.23432,
  "x10":"hq",
  "t1": {"key":"/key/xx1","text":"apple"},
  "x12": { "x1":10},
  "x13":"B",
  "x14":{"$type": "DemoD2", "x1":1, "x2":2},
  "v2":{"x":1, "y":2},
  "v3":{"x":1.1, "y":2.2, "z":3.4},
  "v4":{"x":10.1, "y":11.2, "z":12.3, "w":13.4},
  "t1":"1970-01-01 00:00:00",
  "k1":[1,2],
  "k2":[2,3],
  "k7":[2,3],
  "k8":[[2,2],[4,10]],
  "k9":[{"y1":1, "y2":true},{"y1":2, "y2":false}],
  "k15":[{"$type": "DemoD2", "x1":1, "x2":2}]
}
```
:::
::: tab LUA 
```lua
return 
{
  x1 = false,
  x2 = 2,
  x3 = 128,
  x4 = 1122,
  x5 = 112233445566,
  x6 = 1.3,
  x7 = 1122,
  x10 = "yf",
  t1 = {key="/key/ab1", text="apple"},
  x12 = {x1=1},
  x13 = "D",
  x14 = { _type_="DemoD2", x1 = 1, x2=3},
  v2 = {x= 1,y = 2},
  v3 = {x=0.1, y= 0.2,z=0.3},
  v4 = {x=1,y=2,z=3.5,w=4},
  t1 = "1970-01-01 00:00:00",
  k1 = {1,2},
  k2 = {2,3},
  k8 = {[2]=10,[3]=12},
  k9 = { {y1=1,y2=true}, {y1=10,y2=false} },
  k15 = { { _type_="DemoD2", x1 = 1, x2=3} },
}
```
:::
::: tab XML
```xml
<data>
  <x1>true</x1>
  <x2>4</x2>
  <x3>128</x3>
  <x4>1</x4>
  <x5>112233445566</x5>
  <x6>1.3</x6>
  <x7>1112232.43123</x7>
  <x10>yf</x10>
  <x12> <x1>1</x1> </x12>
  <x13>C</x13>
  <x14 __type__="DemoD2">  <x1>1</x1>  <x2>2</x2> </x14>
  <v2>1,2</v2>
  <v3>1.2,2.3,3.4</v3>
  <v4>1.2,2.2,3.2,4.3</v4>
  <t1>1970-01-01 00:00:00</t1>
  <k1> <item>1</item> <item>2</item> </k1>
  <k2> <item>1</item> <item>2</item> </k2>
  <k8>
      <item> <key>2</key><value>10</value></item>
      <item> <key>3</key><value>30</value></item>
  </k8>
  <k9>
      <item> <y1>1</y1> <y2>true</y2> </item>
      <item> <y1>2</y1> <y2>false</y2> </item>
  </k9>
  <k15>
      <item __type__="DemoD2"> <x1>1</x1> <x2>2</x2> </item>
  </k15>
</data>
```
:::
::: tab YAML
```yaml
x1: true
x2: 3
x3: 128
x4: 40
x5: 11223344
x6: 1.2
x7: 1.23432
x10: hq
x12:
  x1: 10
x13: B
x14:
  $type: DemoD2
  x1: 1
  x2: 2
s1:
  key: "/key32"
  text: aabbcc22
v2:
  x: 1
  y: 2
v3:
  x: 1.1
  y: 2.2
  z: 3.4
v4:
  x: 10.1
  y: 11.2
  z: 12.3
  w: 13.4
t1: '1970-01-01 00:00:00'
k1:
- 1
- 2
k2:
- 2
- 3
k8:
- - 2
  - 2
- - 4
  - 10
k9:
- y1: 1
  y2: true
- y1: 2
  y2: false
k15:
- $type: DemoD2
  x1: 1
  x2: 2
```
:::
::::

### Organize in compound files

Here we only give examples of JSON data source files, other formats are similar

The entire table is organized in the form of one or more json files. Manually specify the json data source in the input attribute of the table, in the following formats:

- `xxx.json`, read xxx.json as a record.
- `*@xxx.json`, read xxx.json as a list of records.
- `field@xxx.json`, read the field field in xxx.json as a record. field can be a deep-level field, such as a.b.c.
- `*field@xxx.json`, read the field field in xxx.json as a list of records. field can be a deep field.

What's more interesting is that, similar to the xlsx data source, it supports putting multiple tables into the same json, but this is rarely done in practice.

As the following example:

- TbCompositeJsonTable1 reads a list of records from the table1 field of composite_tables.json, reads a list of records from composite_tables2.json, and reads a record from one_record.json
- TbCompositeJsonTable2 reads a list of records from the table2 field of composite_tables.json
- TbCompositeJsonTable3 reads a record from the table3 field of composite_tables.json

```xml
<bean name="CompositeJsonTable1">
    <var name="id" type="int"/>
    <var name="x" type="string"/>
</bean>
<bean name="CompositeJsonTable2">
    <var name="id" type="int"/>
    <var name="y" type="int"/>
</bean>
<bean name="CompositeJsonTable3">
    <var name="a" type="int"/>
    <var name="b" type="int"/>
</bean>

<table name="TbCompositeJsonTable1" value="CompositeJsonTable1" 
        input="*table1@composite_tables.json,*@composite_tables2.json,one_record.json"/>
<table name="TbCompositeJsonTable2" value="CompositeJsonTable2" 
        input="*table2@composite_tables.json"/>
<table name="TbCompositeJsonTable3" value="CompositeJsonTable3" mode="one" 
        input="table3@composite_tables.json"/>
```

## data tag

Similar to the excel format, the json format supports record tags, and the `__tag__` attribute is used to specify the tag. The example is as follows:

:::: tabs cache-lifetime="5" :options="{ useUrlFragment: false }"
::: tab JSON
```json
{
    "__tag__":"dev",
    "x":1,
    "y":2
}
```
:::
::: tab LUA
```lua
return {
    __tag__ = "dev",
    x = 1,
    y = 2,
}
```
:::
::::
