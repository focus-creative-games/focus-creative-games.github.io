---
title: AOT泛型限制及原理介绍
date: 2022-05-25 11:50:18
permalink: /huatuo/performance/generic_limit/
categories:
  - huatuo
  - performance
tags:
  - 
author: 
  name: walon
  link: https://github.com/pirunxi
---
# 泛型

clr中有两类泛型特性：泛型类型和泛型函数。泛型是c#中使用极其广泛的特性。即使一个没有明显包含泛型的用法，可能隐含了泛型相关的定义或者操作。例如 int[]隐含就实现 `IEnumerable<int>`之类的接口。又如 为async生成状态机代码时，也会隐含生成一些对`System.Runtime.CompilerServices.AsyncTaskMethodBuilder '1<!T>::AwaitUnsafeOnCompleted<!!T1,!!T2>` 之类的泛型代码。

## AOT泛型引发的问题

huatuo实现了相当完整的clr特性，纯解释器部分的泛型无任何使用限制，但对于AOT泛型类则存在一些问题。

例如，你在热更新脚本里定义了个值类型

```csharp
struct MyVector2
{
    public int x;
    public int y;
}
```

想在脚本中创建`List<MyVector2>` 这样的类型，通常来说是不可能的，因为`List<T>`的函数实现跟T直接相关，不同的T相应的代码不同，而List是AOT泛型类，它已经提前编译为native代码，已经无法根据T运行时得到正确的处理代码。故即使huatuo是个功能完整的的运行时，对这种AOT泛型也无法处理。

本质上，因为AOT翻译导致原始IL指令元数据的缺失，进而无法创建出AOT泛型函数的实例。如果原先在AOT中已经生成对应泛型函数的代码，例如假设你在AOT中用过`List<int>.Count`，则在huatuo可以使用。

泛型类，尤其是泛型容器List,Dictionary之类在代码中使用如此广泛，如果因为AOT限制，导致`List<YourHotUpdateType>`都不能运行，那游戏热更新的代码受限就太大了。幸运的是，il2cpp无心插柳的一个设计极大缓解了这个问题。

## 泛型代码共享（Generic Sharing）

先说一下现在的缓解后的限制。 以`List<T>`举例。你可以创建出AOT中使用过的任何List的实例化类型。 你可以对脚本中的任意自定义枚举MyHotUpdateEnum使用`List<MyHotUpdateEnum>`。你可以对于任意的class类型C，使用`List<C>`。

il2cpp为此引入一个概念叫**泛型代码共享** [Generic Sharing](https://blog.unity.com/technology/il2cpp-internals-generic-sharing-implementation)，此技术更早则源于mono。CLR中也有同样的概念，CLR认为所有引用类型实参都一样，所以可以代码共享，例如，为`List<String>`方法编译的代码可以直接用于`List<Stream>`方法，这是因为所有引用类型实参/变量只是指向托管堆的一个8字节指针（这里假设64位系统），但是对于值类型，则必须每种类型都进行代码生成。

il2cpp为了避免泛型代码膨胀，节约内存，在保证代码逻辑正确性的情况下对于一些能够共享代码，只生成一份代码。其中一个最常见的情况，对引用类型和`int`以及`enum`类型，生成共享代码。同样以`List<T>`为例， `List<object>`和`List<string>`的 Count 函数，生成一份代码是完全合理正确的。

那il2cpp会对泛型类型，生成哪些共享代码呢。这里引入一个概念叫**共享归结类型(sharing reduce type)**(不要google了，这词是我发明的)。

### 值类型不支持泛型共享

原因如下：

1. 值类型大小不定，且值类型对齐方式不一样，不同对齐会导致所在的类的布局不同。

::: tip 举例

```csharp
struct A // size = 4
{
    short x;
    short y;
};
struct B // size = 4
{
    int x;
};
class GenericDemo<T> // 当T为A时，size = 6; 当T为B时，size = 8
{
    short x;
    T v;

    public ref T Value => ref v;
};

// 内存布局如下
// |1|2|3|4|5|6|7|8|
// | x |   A   |            // T 为 A 时的内存布局
// | x |   |   B   |        // T 为 B 时的内存布局
```

`GenericDemo<A>`和`GenericDemo<B>` 内存大小和布局不同， v字段在CheckSize类中的偏移不同，显然il2cpp为它们的Value属性生成的访问函数是不能共享的。

:::

2. 相同大小的结构体，在[x64 ABI](https://docs.microsoft.com/zh-cn/cpp/build/x64-software-conventions?redirectedfrom=MSDN&view=msvc-170)是等效的，可以用同等大小的结构体来作共享泛型实例化。但在[arm64 ABI](https://docs.microsoft.com/zh-cn/cpp/build/arm64-windows-abi-conventions?view=msvc-170)却是不行的。

::: tip 举例

`struct IntVec3 { int32_t x, y, z; }` 和 `struct FloatVec3 { float x, y, z}`; 他们虽然大小都是12，但作为函数参数传递时，传参方式是不一样的：

- IntVec3 以引用的方式传参
- FloatVec3 的三个字段，分别放到三个浮点寄存器里

这个是结构体无法泛型共享的另一个关键原因

:::



## Sharing Reduce Type

计算规则如下

### 非枚举的值类型

reduce type为自身。如int的reduce type为int

### 枚举类型

reduce type为 underlying type与它相同的枚举。例如

```csharp
enum MyEnum 
{
    A = 1,
}

enum MyEnum2 : byte
{
    A = 10,
}
```

由于enum的默认underlying type是int，因此MyEnum的reduce type为 Int32Enum,MyEnum2的reduce type为 ByteEnum。

### class引用类型

reduce type为 object

### 泛型类型

`GenericType<T1,T2,...>` 如果是class类型则reduce type为object，否则reduce type为`GenericType<ReduceType<T1>`, `ReduceType<T2>...>`。

例如

- `Dictionary<int, string>`的reduce type为`object`。
- `YourValueType<int, string>`的reduce type为`YourValueType<int,object>`

## Reduce Type的函数共享

对泛型类型的所有泛型实例化参数进行Sharing Reduce Type计算后，得到最终的泛型共享类型(final sharing generic type) `GenericType<ReduceType<T1>, ReduceType<T2>...>`。

粗略来说（实际规则远比这个复杂，尤其是泛型函数共享），il2cpp会为泛型生成它的共享类型的共享函数。所有相同reduce type的类的**可共享**(不是所有函数都可共享)这些函数。

举例 `List<object>, List<string>, List<GameObject>`的Count 函数，都对应同一份代码，这几个类的的运行时元数据中的Count函数的函数指针都指向相同的c++函数。

至此真相大白，这就是为什么huatuo允许你在热更新代码中随意使用`List<YourClassType>`的原因。

## 泛型函数

对于普通的非虚成员或者静态泛型函数，如示例中`void Fire<T>(T obj)`，它有跟泛型类成员函数相似的代码共享规则。这意味着对于`go.AddComponent<YourHotUpdateMonoBehaviour>()` 这样的泛型函数，尽管你从未在AOT中使用过它，你仍然能在huatuo中写出这样的代码并且正确运行的原因。

但泛型函数的共享规则远比泛型类的普通函数更复杂，因为clr支持神奇的泛型虚函数，如下例子

```csharp
interface IFoo
{
    void Show<T>();
}

class FooImpl : IFoo
{
    
    public void Show<T>()
    {
        UnityEngine.Debug.Log(typeof(t));
    }
    
    public virtual void Run<T>()
    {
        UnityEngine.Debug.Log(default(T));
    }
    
    public void Fire<T>(T obj)
    {
        UnityEngine.Debug.Log(obj);
    }
}
```

例子中 `Show<T>` 是泛型接口函数。 `Run<T>`是普通泛型虚函数。

这些虚泛型函数又引发一个新的概念 RGCTX，机制复杂，这里不再展开讲述。但泛型虚函数，也是遵循相同的代码共享规则。

## 泛型函数的共享泛型函数 计算示例

泛型类型信息本身只是元数据，内存中可以构造出任意的AOT泛型类型信息，本质上缺失的是AOT泛型类的函数。

对于 `Class<C1, C2, ...>.Method<M1, M2, ...>(A1, A2, ...)` 的AOT泛型函数为
`Class<reduce(C1), reduce(C2), ...>.Method<reduce(M1), reduce(M2), ...>(reduce(A1), reduce(A2), ...)`

- `List<string>.ctor` 对应共享函数为 `List<object>.ctor`
- `List<int>.Add(int)` 对应共享函数为 `List<int>.Add(int)`
- `YourGenericClass<string, int, List<int>>.Show<string, List<int>, int>(ValueTuple<int, string>, string, int)` 的共享函数为 `YourGenericClass<object, int, object>.Show<object, object, int>(ValueTuple<int, object>, object, int)`

一个很有用的小技巧，RefTypes.cs 中添加对应AOT泛型函数的调用时，对于函数参数，通过 default(T) 来指定这个参数。

## c# async与IEnumerable之间语法糖机制引发的AOT泛型问题

编译器可能为会async之类的复杂语法糖生成隐含的AOT泛型引用。故为了让这些机制能够正常工作，也必须解决它们引发的AOT泛型实例化问题。

以async为例，编译器为async生成了若干类及状态机及一些代码，这些隐藏生成的代码中包含了对多个AOT泛型函数的调用，常见的有：

- `void AsyncTaskMethodBuilder::Start<TStateMachine>(ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder::AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder::SetException(Exception exception)`
- `void AsyncTaskMethodBuilder::SetResult()`
- `void AsyncTaskMethodBuilder<T>::Start<TStateMachine>(ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder<T>::AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)`
- `void AsyncTaskMethodBuilder<T>::SetException(Exception exception)`
- `void AsyncTaskMethodBuilder<T>::SetResult(T result)`

如果遇到这些AOT泛型实例化缺失错误，使用标准的泛型AOT的实例化规则去解决这些问题即可。

另外，由于c#编译器对release模式下生成的状态机是ValueType类型，导致无法泛型共享，但debug模式下生成的状态机是class类型，可以泛型共享。因此使用脚本编译dll时，务必加上`scriptCompilationSettings.options = ScriptCompilationOptions.DevelopmentBuild;`代码，这样编译出的状态机是class类型，在热更新代码中能正常工作。

理论上能泛型共享却仍然报错，则原因是你的dll使用了release编译模式，编译async时生成了值类型的状态机（也就是示例中的UIMgr+ShowUId__2是值类型），而值类型是无法泛型共享的。具体情况有两种：

- 如果你的热更新dll直接拷贝自Library/ScriptAssemblies目录。解决办法为在Unity Editor窗口最下面的状态栏，有一个臭虫按钮可以切换 Debug/Release，切换成Debug。
- 如果你的热更新dll使用了类似huatuo_trial项目的HuatuoEditorHelper里编译代码编译出的dll。则因为你少加了`scriptCompilationSettings.options = ScriptCompilationOptions.DevelopmentBuild;`，导致编译出的dll是release模式。

## 代码裁剪

由于unity默认的代码裁剪规则，如果你未在代码中使用过，它是不会为你生成这些reduce type的共享函数的。故为了让 `List<YourHotUpdateClass>` 能够正确运行。你要确保`List<object>`（其实`List<string>`也行）必须在AOT中有正确的实例。

为了避免在脚本中不能使用`List<int>`或者`List<string>`，你得事先在AOT中使用或者引用过这些类型。感谢Generic Sharing，这些引用类不多。

为了方便大家使用，我们会提供一个默认的 RefTypes.cs 代码，它已经包含了对常见泛型类型的实例化。 你也可以自己填写或者扩充它。

## AOT泛型实例化错误的处理示例

### 示例1

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module 
  System.Collections.Generic.IEnumerable'1[System.Byte] 
  System.Linq.Enumerable::Skip<System.Byte>(System.Collections.Generic.IEnumerable'1[System.Byte, System.Init32])
```

你在RefType里加上 `IEnumerable.Skip<byte>(IEnumerable<byte>, int)`的调用。

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      IEnumerable.Skip<byte>((IEnumerable<byte>)null, 0);
  }
}
```

### 示例2

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module void System.Collections.Generic.List<System.String>.ctor()
```

你在RefType里加上 `List<string>.ctor()` 的调用，即 `new List<string>()`。由于**泛型共享机制**，你调用 `new List<object>()` 即可。

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      new List<object>();
  }
}
```

### 示例3

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module 
    void System.ValueType<System.Int32, System.String>.ctor()
```

注意！值类型的空构造函数没有调用相应的构造函数，而是对应 initobj指令。实际上你无法直接引用它，但你只要强制实例化这个类型就行了，preserve这个类的所有函数，自然就会包含.ctor函数了。

实际中你可以用强制装箱 `(object)(default(ValueTuple<int, object>))`。

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      // 以下两种写法都是可以的
      _ = (object)(new ValueTuple<int, object>());
      _ = (object)(default(ValueTuple<int, object>));
  }
}
```

### 示例4

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module void YourGenericClass<System.Int32, List<string>>.Show<List<int>, int>(List<string>, ValueTuple<int, string>, int)
```

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      YourGenericClass<int, object>.Show<object,int>(default(object), default(ValueTuple<int,object>), default(int));
  }
}
```

### 示例5

错误日志

```text
  MissingMethodException: AOT generic method isn't instantiated in aot module System.Void System.Runtime.CompilerService.AsyncVoidMethodBuilder::Start<UIMgr+ShowUId__2>(UIMgr+<ShowUI>d__2&)
```

```csharp
class RefTypes
{

  public void MyAOTRefs()
  {
      var builder = new System.Runtime.CompilerService.AsyncVoidMethodBuilder();
      IAsyncStateMachine asm = default;
      builder.Start(ref asm);
  }
}
```