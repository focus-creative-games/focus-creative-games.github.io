---
title: Differential Hybrid Execution
date: 2022-05-25 11:50:18
permalink: /hybridclr/differential_hybrid_execution/
categories:
    - HybridCLR
tags:
    -
author:
    name: walon
    link: https://github.com/pirunxi
---

# Differential Hybrid Execution

HybridCLR开创性地实现了 Differential Hybrid Execution(DHE) 差分混合执行技术。即可以对AOT dll任意增删改，会智能地让变化或者新增的类和函数以interpreter模式运行，但未改动的类和函数以AOT方式运行，让热更新的游戏逻辑的运行性能基本达到原生AOT的水平。

我们提供一个[示例项目](https://github.com/focus-creative-games/dhe_demo)演示最基础的DHE用法。

## 配置

### 配置需要差分混合执行的assembly

通过`HybridCLR/Settings` 菜单打开配置对话框，将需要差分混合执行的assembly加入到 differentialHybridAssemblies (差分混合执行 dlls)。

差分混合执行assembly与普通的纯热更新assembly的工作流不一样，因为纯热更新assembly不需要打包到主工程中。因此同一个assembly不能同时加入
differentialHybridAssemblies和hotUpdateAssemlies列表。

必须在执行差分混合执行assembly的任何代码之前执行正确的设置（即调用`RuntimeApi::UseDifferentialHybridAOTAssembly`或`RuntimeApi::LoadDifferentialHybridAssembly`），因此不是所有assembly都可以配置成为差分混合执行assembly，因为mscorlib
这样的系统assembly运行时机很早。

所幸像mscorlib这样的assembly也没有差分混合执行的需求。而大多数游戏逻辑assembly都是在热更之后再执行的，满足差分混合执行的条件。

### 配置 差分混合执行的assembly的配置数据的导出目录

配置 HybridCLRSetting中 `differentialHybridOptionOutputDir` 字段。使用`HybridCLR/generate/DHEAssemblyOptionDatas` 会为每个差分混合assembly生成一个  `<assembly>.dhao.bytes` 文件 。

加载差分混合执行assembly需要一些配置数据。例如哪些函数发生变化是离线计算好的，这样不需要运行时判定函数是否发生变化了。配置数据在调用`RuntimeApi::LoadDifferentialHybridAssembly` 作为参数传入。

## 标记函数信息

由于目前只是演示版本，默认假设函数都发生变化，需要你使用`[Unchanged]`手动标注哪些函数未发生变化。

正式版本会自动计算，一般不需要你作任何标记处理。

## 代码中使用

运行时，完成热更新后，对于每个混合执行 assembly，检查是否发生变化，未变化则调用 `RuntimeApi::UseDifferentialHybridAOTAssembly` 让
HybridCLR选择原始AOT assembly，如果发生变化，则调用 `RuntimeApi::LoadDifferentialHybridAssembly` 加载热更新assembly。

注意，由于Unity及il2cpp自身的原因，每个混合执行的assembly在il2cpp初始化时要做预处理。所以如果未变化，一定要调用 `RuntimeApi::UseDifferentialHybridAOTAssembly` 让HybridCLR将assembly恢复到AOT状态，否则会执行出错甚至崩溃！！！

一定要按照assembly的依赖顺序加载 差分混合执行 assembly。

示例代码如下。

```csharp
void InitDifferentialHybridAssembly(string assemblyName)
{
    if (CheckNotChange(assemblyName))
    {
        RuntimeApi::UseDifferentialHybridAOTAssembly(assemblyName);
    }
    else
    {
        LoadImageErrCode err = RuntimeApi::UseDifferentialHybridAOTAssembly(GetAssemblyData(assemblyName), GetAssemblyOptionData(assemblyName));
        // ... 处理 err
    }
}
```
## 打包

打包前需要执行 `HybridCLR/generate/DHEAssemblyList` 命令。因为HybridCLR需要在il2cpp初始化的阶段对差分混合执行assembly作预处理，目前
以生成的assembly列表代码的方式提供给HybridCLR。

示例如下:

```cpp
    // Il2CppCompatibleDefs.cpp 文件

	const char* g_differentialHybridAssemblies[]
	{

	//!!!{{DHE
        "Assembly-CSharp",
	//!!!}}DHE
		nullptr,
	};

```

使用 `HybridCLR/generate/DHEAssemblyOptionDatas` 生成 相关配置数据文件，酌情配合实际项目的打包流程使用。

## 限制

考虑到各种因素，目前 Differential Hybrid Execution相关功能只是基础演示版本，有较多的限制。

- 需要手动标记哪些函数未发生变化。 正式版本不需要任何设置。
- 不支持泛型的混合差分执行，也就是本assembly中定义的泛型必然以解释方式执行。 正式版本没有这个限制。
- 函数中不能有`new YourClass()`， `typeof(YourClass)` 之类的直接或间接引用到 混合差分assemly的原始AOT元数据信息的代码。 正式版本没有这个限制。
- 如果函数Foo以非虚函数方式调用了函数Bar，而函数Bar发生了变化，则Foo必然也发生变化，如果强行将Foo标记为未发生改变，将会错误地调用到原始AOT版本的Bar函数，导致不正确的结果。 正式版本没有这个限制。

