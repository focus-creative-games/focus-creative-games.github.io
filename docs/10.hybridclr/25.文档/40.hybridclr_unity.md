---
title: hybridclr_unity package介绍
date: 2022-05-25 11:50:18
permalink: /hybridclr/hybridclr_unity/
categories:
    - HybridCLR
tags:
    -
author:
    name: walon
    link: https://github.com/pirunxi
---

# hybridclr_unity

hybridclr_unity是一个Unity package，它提供了HybridCLR所需的Editor工作流工具脚本及Runtime脚本。借助
hybridclr_unity提供的工作流工具，打包一个支持HybridCLR热更新功能的App变得非常简单。


hybridclr_unity工具主要包含：

- Editor相关脚本
- iOSBuild脚本
- Runtime相关脚本

## 安装 

从git url安装 `com.focus-creative-games.hybridclr_unity` [gitee(推荐)](https://gitee.com/focus-creative-games/hybridclr_unity)或[github](https://github.com/focus-creative-games/hybridclr_unity) package。
不熟悉从url安装package的请看[install from giturl](https://docs.unity3d.com/Manual/upm-ui-giturl.html)。

由于国内网络原因，在unity中可能遇到网络异常而无法安装。你可以先把 `com.focus-creative-games.hybridclr_unity` clone或者下载到本地，然后再 [install from disk](https://docs.unity3d.com/Manual/upm-ui-local.html)。

或者更简单一点的做法，下载到本地后，将仓库文件夹目录改名为`com.focus-creative-games.hybridclr_unity`，直接复制到你们项目的`Packages`目录下即可。

## HybridCLR菜单介绍

### Installer...

提供一个方便的安装器，帮助正确设置本地il2cpp目录，其中包含替换`HybridCLRData/LocalIl2CppData-{platform}/il2cpp/libil2cpp`目录为HybridCLR修改版本。

安装器需要从匹配版本的Unity安装目录复制il2cpp相关文件。

- 对于2019.4.40、2021.3.21+、2021.3.0+ 版本，直接从该版本的安装目录复制il2cpp文件。
- 对于2020.3.16-2020.3.20版本，需要额外安装2020.3.21+版本，因为这些版本的il2cpp文件与HybridCLR不兼容，但可以使用兼容版本(即2020.3.21+)的il2cpp。

安装界面中 `安装状态：已安装|未安装` 指示是否完成HybridCLR初始化。

安装界面中 `il2cpp_plus分支对应的Unity兼容版本的il2cpp路径` 必须满足几个条件：

- 必须是兼容的unity版本的il2cpp目录
- 路径中必须包含unity版本号（Installer用来识别Unity版本，以及用于防止新手选错目录）

如果路径合法，则界面显示正常，否则将会出现红色警告。

点击安装，如成功，则最后会显示`安装成功`日志，并且安装状态切换为`已安装`，否则请检查错误日志。

如果已经安装HybridCLR，点击安装按钮会安装最新的HybridCLR版本的libil2cpp。

### Compile Dll

对于每个target，必须使用目标平台编译开关下编译出的热更新dll，否则会出现热更新代码与AOT主包或者热更新资源的代码信息不匹配的情况。

不匹配时Unity会打印此类日志： `A scripted object (probably XXX?) has a different serialization layout when loading. Did you #ifdef UNITY_EDITOR a section of your serialized properties in any of your scripts?`。

借助Unity的`PlayerBuildInterface.CompilePlayerScripts`Api，hybridclr_unity提供一个编译各个target对应的热更新dll的编译脚本，编译完成后的热更新dll放到 `{project}/HybridCLRData/HotUpdateDlls/{platform}` 目录下。

开发者灵活选择恰当的方式去使用这些热更新dll。

### Generate

Generate下包含多种生成工具。

#### LinkXml

扫描热更新dll引用的AOT类型，生成link.xml，避免热更新脚本用到的AOT类型或函数被裁剪。输出的文件路径在 HybridCLRGlobalSettings.asset中`OuputLinkXml`字段中指定，默认为`LinkGenerator/link.xml`。

更具体的裁剪相关介绍请看[代码裁剪原理及解决办法](/hybridclr/code_striping/)。

#### MethodBridge

根据当前的AOT dll集扫描生成桥接函数文件。HybridCLRGlobalSettings.asset中`maxGenericReferenceIteration`字段指定了泛型递归扫描最大迭代轮数。大多数项目取
10以内即可。

更具体的桥接函数相关文档请看[桥接函数](/hybridclr/method_bridge/)文档。

#### AOTGenericReference

根据当前热更新dll扫描出所有产生的AOT泛型类型及函数的实例化，并生成一个**启发的**泛型实例化文件。

HybridCLRGlobalSettings.asset中`outputAOTGenericReferenceFile`字段指定了输出文件路径，`maxGenericReferenceIteration`字段指定泛型递归扫描的最大迭代次数。

由于将扫描出的泛型类型及函数转换为对应的代码引用比较麻烦，生成的所有泛型实例化代码都是**注释代码**，由开发者自己酌情转换为正确的实例化引用。

请在其他文件中添加泛型类型及函数的实例化引用，因为这个输出文件每次重新生成后会被覆盖。

更具体的AOT泛型相关文档请看[AOT泛型介绍](/hybridclr/aot_generic/)。

#### ReversePInvokeWrapper

为标记了`[MonoPInvokeCallback]`注解的热更新C#静态函数生成一个 ReversePInvokeWrapper函数。这样每个热更新C#静态函数将有一个唯一对应的c++函数，
可以被用于注册到lua之类的脚本语言中，并且被脚本语言调用。

HybridCLRGlobalSettings.asset中`ReversePInvokeWrapperCount`字段指示生成的wrapper c++函数的个数，请预留足够多，确保超过热更新C#代码中标记了`[MonoPInvokeCallback]`注释的C#函数的个数。否则可能会抛出异常。

更具体的MonoPInvokeCallback介绍请看文档[MonoPInvokeCallback支持](/hybridclr/monopinvokecallback/)

#### All

一键执行上面4种生成操作。

## HybridCLRGlobalSettings.asset 配置

HybridCLRGlobalSettings.asset 是一个全局单例Editor配置，定义了hybridclr_unity package所需的配置字段。

如果你项目还没有创建HybridCLRGlobalSettings配置，运行package的一些菜单命令时，第一次访问访问全局配置时会自动在Assets下创建一个配置。你也可以手动Content中右键`Create/HybridCLR/GlobalSettings` 创建一个配置。

该配置是单例，一个项目中不能包含多个，否则使用package自带的菜单命令时会报错。

下面是字段详细说明。

### enable

是否开启HyridCLR热更。默认true。如果为false,则打包不再包含HybridCLR功能。

### cloneFromGitee

是否从gitee clone HybridCLR相关源码。 默认为true。 如果为false，则从github clone。考虑到国内网络环境，建议开启。

### hotUpdateAssemblyDefinitions

以assembly definition(asmdef) 形式定义的热更新模块列表，它与下面的`hotUpdateAssemblies`是等效的，只不过编辑器下拖入asmdef模块比较方便，也不容易失误写错名称。

`hotUpdateAssemblyDefinitions`和`hotUpdateAssemblies`合并后构成最终的热更新dll列表。同一个assembly不要在两个列表中同时出现，会报错！

### hotUpdateAssemblies

有一些assembly以dll形式存在，例如你在外部工程中创建的热更新dll，又如你直接使用Assembly-CSharp作为你的热更新dll。由于没有对应的asmdef文件，只能以dll名称形式手动配置。

填写assembly名称时不要包含'.dll'后缀，像`Main`、`Assembly-CSharp`这样即可。

asmdef形式的assembly，你也可以选择不加到`hotUpdateAssemblyDefinitions`，而是加到`hotUpdateAssemblies`。不过这样不如直接拖入列表方便，你自己酌情选择。

`hotUpdateAssemblyDefinitions`和`hotUpdateAssemblies`合并后构成最终的热更新dll列表。同一个assembly不要在两个列表中同时出现，会报错！

### outputLinkFile

运行菜单`HybridCLR/Generate/LinkXml`命令时，输出的link.xml文件路径。

千万不要指向 `Assets/link.xml`，那个link.xml一般用来手动预留AOT类型，而这个自动输出的link.xml每次都会覆盖。

### outputAOTGenericReferenceFile

运行菜单`HybridCLR/Generate/AOTGenericReference`时输出的AOT泛型实例化集合文件的路径。

### maxGenericReferenceIteration

运行菜单`HybridCLR/Generate/AOTGenericReference`时，生成工具递归分析AOT泛型实例化的迭代次数。

因为泛型函数中可能会间接使用了新的泛型类和泛型函数，因此需要多轮迭代才能分析出所有的泛型实例化，`maxGenericReferenceIteration`参数用于控制迭代次数。这个参数一般10以内就够了，你通过观察日志
能看到几轮迭代后计算终止，如果迭代终止时还有大量泛型未计算迭代，可以适当增加这个值。

为什么不反复迭代直至计算出所有泛型实例化呢？因为有可能出现永远无法计算完的情况。如下代码，AOT.Show()
由于递归泛型实例化，永远也无法计算完。

```csharp

    struct AOT<A>
    {

        public void Show()
        {
            var a = new AOT<AOT<A>>();
            a.Show();
        }
    }

```

### maxMethodBridgeGenericIteration

运行菜单`HybridCLR/Generate/MethodBridge`时，生成工具递归分析AOT泛型实例化的迭代次数。含义与`maxGenericReferenceIteration`相似。

## Editor相关工具

主要包含以下功能：

- 初始化HybridCLR
- 检查和修复设置
- 打包时自动排除热更新assembly
- 打包时将热更新dll名添加到assembly列表
- 备份裁剪后的AOT dll
- 生成一些打包需要的文件和代码
- 编译用于目标平台的热更新dll

### 初始化HybridCLR

运行`HybridCLR/Installer...`菜单命令完成初始化操作。详细见上面的菜单命令介绍。

### 检查和修复设置

属于打包工作流的一部分，相关代码在 `Editor/BuildProcessors/CheckSettings.cs`中。

包含以下操作：

- 根据是否开启HybridCLR，设置或者清除UNITY_IL2CPP_PATH环境变量。脚本中修改的UNITY_IL2CPP_PATH环境变量是本进程的环境变量，不用担心干扰了其他项目。
- 如果检测到意外开启增量式GC，自动关闭这个选项。
- 如果HybridCLRGlobalSettings里未设置任何热更新assembly，提示错误。


### 打包时自动排除热更新assembly

属于打包工作流的一部分，相关代码在 `Editor/BuildProcessors/FilterHotFixAssemblies.cs`中。

很显然，热更新assembly不应该被il2cpp处理并且编译到最终的包体里。我们处理了`IFilterBuildAssemblies`回调，
将热更新dll从build assemblies列表移除。

脚本中会额外检查是否写错assembly名字，以及是否失误配置了重复的assembly。

### 打包时将热更新dll名添加到assembly列表

属于打包工作流的一部分，相关代码在 `Editor/BuildProcessors/PatchScriptingAssemblyList.cs`中。

工具在打包时，会自动将热更新assembly的dll名加入assembly列表配置文件。

热更新MonoBehaviour脚本所在的assembly的dll名必须添加到assembly列表配置文件，Unity的资源管理系统才能正确识别
和还原热更新脚本。更详细的原理介绍请看 [使用热更新MonoBehaviour](/hybridclr/monobehaviour/) 。

### 备份裁剪后的AOT dll

属于打包工作流的一部分，相关代码在 `Editor/BuildProcessors/CopyStrippedAOTAssemblies.cs`中。

`补充元数据` 技术需要使用打包时生成的裁剪后的AOT dll。因此将打包过程中生成的裁剪后的AOT dll
复制到 `{project}/HybridCLRData/AssembliesPostIl2CppStrip/{platform}`目录，方便将来处理。

`补充元数据` 更详细的原理性文档请看 [AOT泛型原理](/hybridclr/aot_generic/)

### 生成一些打包需要的文件和代码

包含以下几个生成功能：

- 扫描生成link.xml
- 生成桥接函数
- 生成AOT泛型实例化代码
- 生成ReversePInvokeCallback相关wrapper文件

菜单`HybridCLR/Generate/*`中包含了这些生成命令，请看上面的介绍文档。

## iOSBuild脚本

package中 `Editor/Data~/iOSBuild` 包含了编译iOS版本libil2cpp.a所需的脚本。在运行`HybridCLR/Installer...`菜单命令成功初始化HybridCLR后，会自动复制到`{project}/HybridCLRData/iOSBuild`目录。**后续操作必须在`{project}/HybridCLRData/iOSBuild`目录进行**。

build libil2cpp.a的具体操作请看文档 [iOS平台打包](/hybridclr/build_ios_libil2cpp/)。

## Runtime相关脚本

包含运行时用到的类。目前比较简单。

### LoadImageErrorCode

加载热更新dll的错误码。

### RuntimeApi

底层的操作HybridCLR的工具类。比较常用的是`public static unsafe LoadImageErrorCode LoadMetadataForAOTAssembly(byte[] dllBytes)`函数，
用于加载补充元数据assembly。
