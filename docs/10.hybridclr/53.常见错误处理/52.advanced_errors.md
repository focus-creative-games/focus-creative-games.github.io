---
title: 进阶版常见错误
date: 2022-05-25 11:50:18
permalink: /hybridclr/errors/advanced_errors/
categories:
  - HybridCLR
  - errors
tags:
  - 
author: 
  name: walon
  link: https://github.com/pirunxi
---
# 进阶版常见错误

# 裁剪错误

## 遇到  MissingMethodException xxx 错误

如果未出现AOT generic method的字眼，则这是unity代码裁剪引起的函数丢失，你使用常规的避免unity代码裁剪的方式处理即可。

常规两种做法

- 在link.xml preserve这个函数。
- 主工程中显式带上类或者函数的使用，如[hybridclr_trial](https://github.com/focus-creative-games/hybridclr_trial)中Assets/Main/hybridclrLib/RefTypes.cs所做的那样。

## 遇到 Unity: TypeLoadException xxx 错误

同样是unity代码裁剪引用的类型缺失。处理方法同上。

## 遇到'ExecutionEngineException: Image::ReadTypeFromResolutionScope ReadTypeFromResolutionScope.TYPEREF fail' 
由裁剪引起，裁剪的是类的内部类。

## 遇到 ExecutionEngineException: metadata type not match

在 LoadMetadataForAOTAssembly 方法中，载入的dll，使用了裁剪之前的版本。应该时候裁剪之后的，具体使用可以参照hybridclr_trial项目。在BuildProcessor中，生成裁剪后的dll后，将dll拷贝到他处。

# AOT泛型函数问题

## 遇到 MissingMethodException: AOT generic method isn't instantiated in aot module xxx 错误

这是因为AOT泛型函数实例化缺失引起的，

::: danger 一定要
请先详细看一下[AOT泛型限制及原理介绍](/hybridclr/performance/generic_limit/) 文档。
:::

解决办法为：错误日志告诉你缺失哪个AOT函数实例化，你就在主工程里加上对这个函数的调用，使得il2cpp在打包时能生成这个泛型函数的代码。 主工程里任意地方加个这个泛型AOT函数调用都可以，目前一般集中加到 RefTypes.cs 这个文件里。

如果是async相关代码发生这种错误(具体见下面的示例5)，则是因为编译器为async生成了若干类及状态机及一些代码，这些隐藏生成的代码中包含了对AOT泛型函数（如示例5中`void System.Runtime.CompilerServices.AsyncVoidMethodBuilder::Start<T>(ref T)`） 的调用。用常规的AOT泛型的解决办法处理它即可。但有时候，你添加了`void System.Runtime.CompilerService.AsyncVoidMethodBuilder::Start<StateMachine>(StateMachine&)`的泛型实例化，理论上能泛型共享却仍然报错，则原因是你的dll使用了release编译模式，编译async时生成了值类型的状态机（也就是示例中的UIMgr+ShowUId__2是值类型），而值类型是无法泛型共享的。具体情况有两种：

- 如果你的热更新dll直接拷贝自Library/ScriptAssemblies目录。解决办法为在Unity Editor窗口最下面的状态栏，有一个臭虫按钮可以切换 Debug/Release，切换成Debug。
- 如果你的热更新dll使用了类似hybridclr_trial项目的HybridCLREditorHelper里编译代码编译出的dll。则因为你少加了`scriptCompilationSettings.options = ScriptCompilationOptions.DevelopmentBuild;`，导致编译出的dll是release模式。

::: warning 并且务必
清除你的Library/Il2cppBuildCache目录及已经打包好的dll。
:::

如何添加AOT泛型实例，参见 [泛型共享原理](/hybridclr/performance/generic_limit/) 中的示例
### 示例1

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module 
  System.Collections.Generic.IEnumerable'1[
    [System.Byte,mscorlib,Version=4.0.0.0,Culture=neutral,
    PublicKeyToken=b77a5c561934e089]
  ] 
  System.Linq.Enumerable::Skip<System.Byte>(System.Collections.Generic.IEnumerable'1[
    [System.Byte,mscorlib,Version=4.0.0.0,Culture=neutral,PublicKeyToken=b77a5c561934e089],
    System.Init32]
  ]
```

你在RefType里加上 `IEnumerable.Skip<byte>(IEnumerable<byte>, int)`的调用。

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      IEnumerable.Skip<byte>((IEnumerable<byte>)null, 0);
  }
}
```

### 示例2

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module 
    void System.Collections.Generic.List<System.String>.ctor()
```

你在RefType里加上 `List<string>.ctor()` 的调用，即 `new List<string>()`。由于**泛型共享机制**，你调用 `new List<object>()` 即可。

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      new List<object>();
  }
}
```

### 示例3

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module 
    void System.ValueType<System.Int32, System.String>.ctor()
```

注意！值类型的空构造函数没有调用相应的构造函数，而是对应 initobj指令。实际上你无法直接引用它，但你只要强制实例化这个类型就行了，preserve这个类的所有函数，自然就会包含.ctor函数了。

实际中你可以用强制装箱 `(object)(default(ValueTuple<int, object>))`。

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      // 以下两种写法都是可以的
      _ = (object)(new ValueTuple<int, object>());
      _ = (object)(default(ValueTuple<int, object>));
  }
}
```

### 示例4

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module 
    void YourGenericClass<System.Int32, List<string>>.Show<List<int>, int>(List<string>, ValueTuple<int, string>, int)
```

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      YourGenericClass<int, object>.Show<object,int>(default(object), default(ValueTuple<int,object>), default(int));
  }
}
```

### 示例5

错误日志

```text
MissingMethodException: AOT generic method isn't instantiated in aot module
  System.Void System.Runtime.CompilerService.AsyncVoidMethodBuilder::Start<UIMgr+ShowUId__2>(UIMgr+<ShowUI>d__2)
```

```csharp
class RefTypes
{
  public void MyAOTRefs()
  {
      var builder = new System.Runtime.CompilerService.AsyncVoidMethodBuilder();
      builder.Start(default(IAsyncStateMachine));
  }
}
```
## 遇到ExecutionEngineException:xxx method body is null. not support external method... 
接SDK中容易遇到这个错误，这是由于不支持在热更新中定义external函数，需要放到AOT部分。


# 桥接函数问题

## 遇到 ExecutionEngineException: GetManaged2NativeMethodPointer not support. xxxx 函数名

这是因为这个AOT函数与interpreter之间的桥接函数不存在。请参考 [桥接函数](/hybridclr/performance/method_bridge/) 文档进行处理。

## 遇到'ExecutionEngineException: NotSupportNative2Managed App' 
原理：Native表示AOT，Manage表示解释器，准确来说，Native2Managed表示AOT2Interpreter的调用。

发生错误的原因：Native到解释器的调用时找不到桥接函数。如果桥接函数不存在，就会出现这个问题，Native2Managed这个回调函数，取不到函数参数，导致无法打印签名。

因此，定位出没找到桥接函数的那个函数，添加对应签名的delegate到自定义桥接函数列表就可以了。

解决方法：

1.从错误日志里面，定位出哪个C#函数抛出的异常，在这个函数中找到delegate调用，然后把delegate加到CustomeTypes列表。

或者

2.把桥接函数生成的ScanType函数过滤条件删除，减少此类情况出现。

例如：
```csharp
    SortedDictionary<string, string> dic = new SortedDictionary<string, string>();

    public void Add(Tkey key,TValue value)
    {
      _set.Add(new KeyValuePair<Tkey, TValue>(key, value));
    }

    public bool Add(T item)
    {
      return AddIfNotPresent(item)；
    }

    internal virtual bool AddIfNotPresent(T item)
    {
        ...
        while(...)
        {
          num = comparer.Compare(item, node.Item);
          ...
        }
    }
```
问题出现在comparer.Compare 上，它的签名是 T Compare(T, T)，以SortedDictionary<string, string>为例，它的T是KeyValuePaire<string, string>, 那么Compare的签名就是int(KeyValuePaire<string, string>, KeyValuePaire<string, string>)。于是添加Func<KeyValuePaire<string, string>,KeyValuePaire<string, string>, int> 这个delegate到自定义桥接函数列表。

具体添加什么，要根据 SortedDictionary<T, V> 的泛型参数。对应添加 Func<SortedDictionary<K, V>, SortedDictionary<K, V>, int>。