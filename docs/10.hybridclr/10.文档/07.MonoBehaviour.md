---
title: MonoBehaviour相关工作流
date: 2022-05-25 11:50:18
permalink: /hybridclr/performance/MonoBehaviour/
categories:
  - HybridCLR
  - performance
tags:
  - 
author: 
  name: walon
  link: https://github.com/pirunxi
---
# 热更新MonoBehaviour的工作流

文档中提及的代码文件在[HybridCLR_trail](https://github.com/focus-creative-games/hybridclr_trial)


## 通过代码使用

`AddComponent<T>()`或者`AddComponent(Type type)`任何时候都是完美支持的。不需要像资源上挂载脚本那样做一些特殊处理。

## 在资源上挂载MonoBehaviour

如果想在资源上挂载热更新脚本，由于unity资源管理的限制，需要在打包时做少量特殊处理。

### 原理

Unity资源管理在反序列化资源中的脚本时，要求满足以下条件：

- 必须是使用AssetBundle打包的资源
- 脚本所在的dll必须在打包生成的 ScriptingAssemblies.json中存在。这个列表是unity启动时即加载的，不可变数据。
- 脚本所有的dll已经加载到AppDomain中

如果对打包流程不作任何改变，由于热更新dll肯定不会出现在ScriptingAssemblies.json中，挂载在热更新资源中的热更新脚本肯定是无法被
还原的，因此我们在 `HybridCLR.Editor.BuildProcessors.BPPatchScriptAssembliesJson` 脚本中处理了OnPostprocessBuild事件，把热更新dll加入到json文件的dll列表中。具体
操作为把你项目中包含希望挂在资源上的热更新MonoBehaviour的dll加入到 `HybridCLR.Editor.BuildConfig.HotUpdateAssemblies` 中。

由于只需要满足这两个条件即成正确恢复资源上的脚本，热更新脚本可以按照项目需求**自由选择热更新方式**，可以将dll打包到ab中，或者裸数据
文件，或者加密压缩等等。只要能保证在加载热更新资源前使用Assembly.Load将其加载即可。

另外，为了不让热更新dll在打包时导出，我们又在 `HybridCLR.Editor.BuildProcessors.BPFilterHotFixAssemblies` 脚本中处理了 IFilterBuildAssemblies.OnFilterAssemblies 事件，将热更新dll忽略。
这样一样，直接将热更新assembly def像普通的assembly那样，标记为导出给所有平台，也不会在打包时导出了。具体操作为把你的的热更新dll加入`HybridCLR.Editor.BuildConfig.HotUpdateAssemblies`列表。

示例如下图:

```csharp
    public static partial class BuildConfig
    {

        /// <summary>
        /// 所有热更新dll列表。放到此列表中的dll在打包时OnFilterAssemblies回调中被过滤。
        /// </summary>
        public static List<string> HotUpdateAssemblies { get; } = new List<string>
        {
            "HotFix.dll",
            "HotFix2.dll",
        };

        public static List<string> AOTMetaAssemblies { get; } = new List<string>()
        {
            "mscorlib.dll",
            "System.dll",
            "System.Core.dll", // 如果使用了Linq，需要这个
        };

        public static List<string> AssetBundleFiles { get; } = new List<string>
        {
            "common",
        };
    }
```

### 准备工作

- 将HybridCLR_trial项目中Assets/Editor/hybridclr复制到你项目的某个Editor目录，假设为`Assets/Editor/hybridclr`
- 打开文件 `HybridCLR.Editor.BuildConfig`，将热更dll名称填入 `HotUpdateAssemblies` 字段，示例:
- 在挂热更脚本的任意一个资源加载之前，加载热更dll，示例代码如下:

    ```csharp
        #if !UNITY_EDITOR
            // 只有打包后才需要加载 HotFix.dll
            AssetBundle dllAB = BetterStreamingAssets.LoadAssetBundle("HybridCLR");
            TextAsset dllBytes = dllAB.LoadAsset<TextAsset>("HotFix.bytes");
            gameAss = System.Reflection.Assembly.Load(dllBytes.bytes);
        #endif

            // 加载热更dll之后再加载挂了热更脚本的资源
            AssetBundle resAB = BetterStreamingAssets.LoadAssetBundle("artRes");
            GameObject go = resAB.LoadAsset<GameObject>("myPrefab");
            Instantiate(go);
    ```

### 打包流程

正常打包即可，但有几个注意事项

- dll可以自由选择AssetBundle或者StreamingAssets或者其他方式更新。如需要把热更dll打包成ab，可参见示例 `Assets/Editor/hybridclr/hybridclrEditorHelper.cs`
- 建议打AB时不要禁用TypeTree，否则普通的AB加载方式会失败。（原因是对于禁用TypeTree的脚本，Unity为了防止二进制不匹配导致反序列化MonoBehaviour过程中进程Crash，会对脚本的签名进行校验，签名的内容是脚本FullName及TypeTree数据生成的Hash, 但由于我们的热更脚本信息不存在于打包后的安装包中，因此校验必定会失败）

- 如果必须要禁用TypeTree，一个变通的方法是禁止脚本的Hash校验, 此种情况下用户必须保证打包时代码与资源版本一致，否则可能会导致Crash，示例代码

    ```csharp
        AssetBundleCreateRequest req = AssetBundle.LoadFromFileAsync(path);
        req.SetEnableCompatibilityChecks(false); // 非public，需要通过反射调用
    ```

### 其它

- 不支持reload dll。想重新加载一个dll只能重启。
- **需要被挂到资源上的脚本所在dll名称（monoDllNames）请事先预留好，上线后勿修改，因为ScriptingAssemblies.json列表打包后无法修改**
